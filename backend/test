backend\Controller\auth-Controller.js

import User from "../models/user.js";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import Verification from "../models/verification.js";
import { sendEmail } from "../libs/send-email.js";
import aj from "../libs/arcjet.js";

const registerUser = async (req, res) => {
  try {
    const { email, name, password, ref } = req.body;
    
    // Check if user is registering with a referral link
    let referredBy = null;
    let role = "manager"; // Default role
    
    if (ref) {
      // Verify the referral link is valid
      const referringUser = await User.findById(ref);
      if (referringUser && referringUser.role === "manager") {
        referredBy = ref;
        role = "user"; // Users who sign up with referral links are regular users
      }
    }

    const decision = await aj.protect(req, { email });
    console.log("Arcjet decision", decision.isDenied());
    if (decision.isDenied()) {
      res.writeHead(403, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ message: "Invalid email address" }));
    }
    
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        message: "Email address already in use",
      });
    }
    
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    
    const newUser = await User.create({
      email,
      password: hashPassword,
      name,
      role,
      referredBy,
    });
    
    const verificationToken = jwt.sign(
      { userId: newUser._id, purpose: "email-verification" },
      process.env.JWT_SECRET,
      { expiresIn: "1h" }
    );
    
    await Verification.create({
      userId: newUser._id,
      token: verificationToken,
      expiresAt: new Date(Date.now() + 1 * 60 * 60 * 1000),
    });
    
    // send email
    const verificationLink = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`;
    const emailBody = `<p>Click <a href="${verificationLink}">here</a> to verify your email</p>`;
    const emailSubject = "Verify your email";
    const isEmailSent = await sendEmail(email, emailSubject, emailBody);
    
    if (!isEmailSent) {
      return res.status(500).json({
        message: "Failed to send verification email",
      });
    }
    
    res.status(201).json({
      message:
        "Verification email sent to your email. Please check and verify your account.",
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select("+password");
    
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }
    
    // Check if user is active
    if (!user.isActive) {
      return res.status(400).json({ message: "Your account has been deactivated. Please contact your manager." });
    }
    
    if (!user.isEmailVerified) {
      const existingVerification = await Verification.findOne({
        userId: user._id,
      });
      
      if (existingVerification && existingVerification.expiresAt > new Date()) {
        return res.status(400).json({
          message:
            "Email not verified. Please check your email for the verification link.",
        });
      } else {
        await Verification.findByIdAndDelete(existingVerification?._id);
        
        const verificationToken = jwt.sign(
          { userId: user._id, purpose: "email-verification" },
          process.env.JWT_SECRET,
          { expiresIn: "1h" }
        );
        
        await Verification.create({
          userId: user._id,
          token: verificationToken,
          expiresAt: new Date(Date.now() + 1 * 60 * 60 * 1000),
        });
        
        // send email
        const verificationLink = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`;
        const emailBody = `<p>Click <a href="${verificationLink}">here</a> to verify your email</p>`;
        const emailSubject = "Verify your email";
        const isEmailSent = await sendEmail(email, emailSubject, emailBody);
        
        if (!isEmailSent) {
          return res.status(500).json({
            message: "Failed to send verification email",
          });
        }
        
        res.status(201).json({
          message:
            "Verification email sent to your email. Please check and verify your account.",
        });
      }
    }
    
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(400).json({ message: "Invalid email or password" });
    }
    
    const token = jwt.sign(
      { userId: user._id, purpose: "login" },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );
    
    user.lastLogin = new Date();
    await user.save();
    
    const userData = user.toObject();
    delete userData.password;
    
    res.status(200).json({
      message: "Login successful",
      token,
      user: userData,
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

const verifyEmail = async (req, res) => {
  try {
    const { token } = req.body;
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    
    if (!payload) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const { userId, purpose } = payload;
    if (purpose !== "email-verification") {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const verification = await Verification.findOne({
      userId,
      token,
    });
    
    if (!verification) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const isTokenExpired = verification.expiresAt < new Date();
    if (isTokenExpired) {
      return res.status(401).json({ message: "Token expired" });
    }
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    if (user.isEmailVerified) {
      return res.status(400).json({ message: "Email already verified" });
    }
    
    user.isEmailVerified = true;
    await user.save();
    
    await Verification.findByIdAndDelete(verification._id);
    
    res.status(200).json({ message: "Email verified successfully" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

const resetPasswordRequest = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    
    if (!user) {
      return res.status(400).json({ message: "User not found" });
    }
    
    if (!user.isEmailVerified) {
      return res
        .status(400)
        .json({ message: "Please verify your email first" });
    }
    
    const existingVerification = await Verification.findOne({
      userId: user._id,
    });
    
    if (existingVerification && existingVerification.expiresAt > new Date()) {
      return res.status(400).json({
        message: "Reset password request already sent",
      });
    }
    
    if (existingVerification && existingVerification.expiresAt < new Date()) {
      await Verification.findByIdAndDelete(existingVerification._id);
    }
    
    const resetPasswordToken = jwt.sign(
      { userId: user._id, purpose: "reset-password" },
      process.env.JWT_SECRET,
      { expiresIn: "15m" }
    );
    
    await Verification.create({
      userId: user._id,
      token: resetPasswordToken,
      expiresAt: new Date(Date.now() + 15 * 60 * 1000),
    });
    
    const resetPasswordLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetPasswordToken}`;
    const emailBody = `<p>Click <a href="${resetPasswordLink}">here</a> to reset your password</p>`;
    const emailSubject = "Reset your password";
    const isEmailSent = await sendEmail(email, emailSubject, emailBody);
    
    if (!isEmailSent) {
      return res.status(500).json({
        message: "Failed to send reset password email",
      });
    }
    
    res.status(200).json({ message: "Reset password email sent" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

const verifyResetPasswordTokenAndResetPassword = async (req, res) => {
  try {
    const { token, newPassword, confirmPassword } = req.body;
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    
    if (!payload) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const { userId, purpose } = payload;
    if (purpose !== "reset-password") {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const verification = await Verification.findOne({
      userId,
      token,
    });
    
    if (!verification) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    const isTokenExpired = verification.expiresAt < new Date();
    if (isTokenExpired) {
      return res.status(401).json({ message: "Token expired" });
    }
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    if (newPassword !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }
    
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(newPassword, salt);
    user.password = hashPassword;
    await user.save();
    
    await Verification.findByIdAndDelete(verification._id);
    
    res.status(200).json({ message: "Password reset successfully" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};

export {
  registerUser,
  loginUser,
  verifyEmail,
  resetPasswordRequest,
  verifyResetPasswordTokenAndResetPassword,
};





// backend/controllers/customProjectStage.js
import CustomProjectStage from "../models/customProjectStage.js";
import Project from "../models/project.js";
import User from "../models/user.js";

// Create a custom project stage
export const createCustomProjectStage = async (req, res) => {
  try {
    const { stage_name, description, project } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Only managers can create custom stages
    if (userRole !== "manager") {
      return res.status(403).json({ success: false, error: "Only managers can create custom stages" });
    }
    
    // Check if project exists and user has permission
    const projectDoc = await Project.findById(project);
    if (!projectDoc) {
      return res.status(404).json({ success: false, error: "Project not found" });
    }
    
    if (projectDoc.owner.toString() !== userId.toString()) {
      return res.status(403).json({ success: false, error: "Access denied" });
    }
    
    const newCustomStage = new CustomProjectStage({
      stage_name,
      description,
      project,
      owner: userId
    });
    
    await newCustomStage.save();
    res.status(201).json({ success: true, customStage: newCustomStage });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ success: false, error: "Server error" });
  }
};

// Get custom stages for a project
export const getCustomProjectStages = async (req, res) => {
  try {
    const { projectId } = req.params;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if project exists and user has permission
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ success: false, error: "Project not found" });
    }
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can see custom stages for their projects
      if (project.owner.toString() !== userId.toString()) {
        return res.status(403).json({ success: false, error: "Access denied" });
      }
    } else if (userRole === "user") {
      // Users can see custom stages for their manager's projects
      const manager = await User.findById(userId);
      if (manager && manager.referredBy) {
        if (project.owner.toString() !== manager.referredBy.toString()) {
          return res.status(403).json({ success: false, error: "Access denied" });
        }
      } else {
        return res.status(403).json({ success: false, error: "Access denied" });
      }
    }
    
    const customStages = await CustomProjectStage.find({ project: projectId })
      .populate('owner', 'name email');
    
    res.status(200).json({ success: true, customStages });
  } catch (error) {
    console.error("Error fetching custom project stages:", error);
    res.status(500).json({ success: false, error: "Error fetching custom project stages" });
  }
};




// backend/controllers/email-controller.js
import Email from "../models/email.js";
import Project from "../models/project.js";
import User from "../models/user.js";
import { generateProjectPDF } from "../libs/pdf-generator.js";
import { sendEmailWithAttachment } from "../libs/send-email.js";
import fs from 'fs'; // Make sure to import fs

// Get all emails
export const getAllEmails = async (req, res) => {
  try {
    const userId = req.user._id;
    const userRole = req.user.role;
    
    let query = {};
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can see their own emails
      query.owner = userId;
    } else if (userRole === "user") {
      // Users can see emails of their manager
      const manager = await User.findById(userId);
      if (manager && manager.referredBy) {
        query.owner = manager.referredBy;
      } else {
        // If user doesn't have a manager, they can't see any emails
        return res.status(200).json([]);
      }
    }
    
    const emails = await Email.find(query)
      .populate('owner', 'name email')
      .sort({ createdAt: -1 });
    
    res.status(200).json(emails);
  } catch (error) {
    console.error("Error fetching emails:", error);
    res.status(500).json({ message: "Error fetching emails", error: error.message });
  }
};

// Add a new email
export const addEmail = async (req, res) => {
  try {
    const { name, email } = req.body;
    const userId = req.user._id;
    
    const newEmail = new Email({
      name,
      email,
      owner: userId
    });
    
    await newEmail.save();
    res.status(201).json({ success: true, email: newEmail });
  } catch (error) {
    console.error("Error adding email:", error);
    res.status(500).json({ message: "Error adding email", error: error.message });
  }
};

// Update an email
export const updateEmail = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email } = req.body;
    const userId = req.user._id;
    
    const updatedEmail = await Email.findOneAndUpdate(
      { _id: id, owner: userId },
      { name, email },
      { new: true }
    );
    
    if (!updatedEmail) {
      return res.status(404).json({ message: "Email not found" });
    }
    
    res.status(200).json(updatedEmail);
  } catch (error) {
    console.error("Error updating email:", error);
    res.status(500).json({ message: "Error updating email", error: error.message });
  }
};

// Delete an email
export const deleteEmail = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;
    
    const deletedEmail = await Email.findOneAndDelete({ _id: id, owner: userId });
    
    if (!deletedEmail) {
      return res.status(404).json({ message: "Email not found" });
    }
    
    res.status(200).json({ message: "Email deleted successfully" });
  } catch (error) {
    console.error("Error deleting email:", error);
    res.status(500).json({ message: "Error deleting email", error: error.message });
  }
};

// Share project details via email with PDF attachment
export const shareProjectDetails = async (req, res) => {
  try {
    const { projectId, emailIds } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    console.log("Sharing project details:", { projectId, emailIds, userId, userRole });
    
    // Check if user has permission to share this project
    const project = await Project.findById(projectId)
      .populate({
        path: 'stages',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .populate('owner', 'name email');
    
    if (!project) {
      console.error("Project not found:", projectId);
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can share projects, and only their own projects
    if (userRole !== "manager" || project.owner._id.toString() !== userId.toString()) {
      console.error("Access denied for user:", userId, "on project:", projectId);
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Get email addresses
    const emails = await Email.find({ _id: { $in: emailIds }, owner: userId });
    
    if (emails.length === 0) {
      console.error("No valid email addresses found for IDs:", emailIds);
      return res.status(404).json({ message: "No valid email addresses found" });
    }
    
    console.log("Found emails:", emails.length);
    
    // Generate PDF with error handling
    let pdfResult;
    try {
      pdfResult = await generateProjectPDF(project.toObject());
      console.log("PDF generated successfully:", pdfResult.fileName);
    } catch (pdfError) {
      console.error("Error generating PDF:", pdfError);
      return res.status(500).json({ message: "Failed to generate PDF", error: pdfError.message });
    }
    
    // Send emails with PDF attachment
    const emailPromises = emails.map(email => {
      const subject = `Project Details: ${project.project_name}`;
      const body = `
        <p>Dear ${email.name},</p>
        <p>Please find attached the detailed report for the project "${project.project_name}".</p>
        <p>This report includes:</p>
        <ul>
          <li>Project information and status</li>
          <li>Complete stage details in both table and card views</li>
          <li>Progress tracking information</li>
        </ul>
        <p>If you have any questions about this project, please feel free to reach out.</p>
        <p>Best regards,<br>${req.user.name}</p>
      `;
      
      return sendEmailWithAttachment(
        email.email,
        subject,
        body,
        pdfResult.filePath,
        pdfResult.fileName
      );
    });
    
    try {
      await Promise.all(emailPromises);
      console.log("All emails sent successfully");
    } catch (emailError) {
      console.error("Error sending emails:", emailError);
      // Try to clean up the PDF file even if emails fail
      try {
        fs.unlinkSync(pdfResult.filePath);
      } catch (unlinkError) {
        console.error("Error deleting temporary PDF file:", unlinkError);
      }
      return res.status(500).json({ message: "Failed to send emails", error: emailError.message });
    }
    
    // Clean up temporary file
    try {
      fs.unlinkSync(pdfResult.filePath);
      console.log("Temporary PDF file deleted");
    } catch (unlinkError) {
      console.error("Error deleting temporary PDF file:", unlinkError);
      // Don't fail the request if we can't delete the temp file
    }
    
    res.status(200).json({ 
      message: `Project details shared successfully with ${emails.length} email address(es)` 
    });
  } catch (error) {
    console.error("Error sharing project details:", error);
    res.status(500).json({ message: "Error sharing project details", error: error.message });
  }
};





\\backend\controllers\project.js

import Project from "../models/project.js";
import ProjectStage from "../models/projectStage.js";
import StageConnection from "../models/stageConnection.js";
import User from "../models/user.js";

// Helper function to create a Date object at noon to avoid timezone issues
const createLocalDate = (dateString) => {
  if (!dateString) return null;
  const date = new Date(dateString);
  // Set time to noon to avoid DST issues
  date.setHours(12, 0, 0, 0);
  return date;
};

// Helper function to format date as YYYY-MM-DD in local timezone
const formatDateToLocal = (date) => {
  if (!date) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Create a new project
export const createProject = async (req, res) => {
  try {
    const { project_name, description, status, created_at } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Only managers can create projects
    if (userRole !== "manager") {
      return res.status(403).json({ success: false, error: "Only managers can create projects" });
    }
    
    // Create a Date object at noon to avoid timezone issues
    const createdAtDate = createLocalDate(created_at);
    
    const newProject = new Project({
      project_name,
      description,
      status: status || "Pending",
      created_at: createdAtDate,
      owner: userId
    });
    
    await newProject.save();
    res.status(201).json({ success: true, project: newProject });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ success: false, error: "Server error" });
  }
};

// Get all projects
export const getAllProjects = async (req, res) => {
  try {
    const { year, month } = req.query;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    let query = {};
    
    // Filter by year if provided and not "all"
    if (year && year !== "all") {
      const yearNum = parseInt(year);
      if (!isNaN(yearNum)) {
        const startDate = new Date(yearNum, 0, 1); // January 1st of the year
        const endDate = new Date(yearNum + 1, 0, 1); // January 1st of the next year
        
        query.created_at = {
          $gte: startDate,
          $lt: endDate
        };
      }
    }
    
    // Filter by month if provided (year must also be provided)
    if (year && month && year !== "all") {
      const yearNum = parseInt(year);
      const monthNum = parseInt(month) - 1; // JavaScript months are 0-indexed
      if (!isNaN(yearNum) && !isNaN(monthNum)) {
        const startDate = new Date(yearNum, monthNum, 1); // First day of the month
        const endDate = new Date(yearNum, monthNum + 1, 1); // First day of the next month
        
        query.created_at = {
          $gte: startDate,
          $lt: endDate
        };
      }
    }
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can see their own projects
      query.owner = userId;
    } else if (userRole === "user") {
      // Users can see projects of their manager
      const manager = await User.findById(userId);
      if (manager && manager.referredBy) {
        query.owner = manager.referredBy;
      } else {
        // If user doesn't have a manager, they can't see any projects
        return res.status(200).json([]);
      }
    }
    
    console.log("Query for projects:", query); // Debug log
    
    const projects = await Project.find(query)
      .populate({
        path: 'stages',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .populate('owner', 'name email')
      .sort({ created_at: -1 }); // Sort by creation date, newest first
    
    // Format dates to YYYY-MM-DD for frontend in local timezone
    const formattedProjects = projects.map(project => {
      const formattedProject = project.toObject();
      formattedProject.created_at = formatDateToLocal(project.created_at);
      
      // Format stage dates
      if (formattedProject.stages && formattedProject.stages.length > 0) {
        formattedProject.stages = formattedProject.stages.map(stage => {
          const formattedStage = { ...stage };
          if (stage.start_date) {
            formattedStage.start_date = formatDateToLocal(stage.start_date);
          }
          if (stage.completion_date) {
            formattedStage.completion_date = formatDateToLocal(stage.completion_date);
          }
          return formattedStage;
        });
      }
      
      return formattedProject;
    });
    
    console.log("Formatted projects:", formattedProjects); // Debug log
    
    res.status(200).json(formattedProjects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    res.status(500).json({ message: "Error fetching projects", error: error.message });
  }
};

// Get a single project with stages
export const getProjectById = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    let query = { _id: id };
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can only access their own projects
      query.owner = userId;
    } else if (userRole === "user") {
      // Users can only access projects of their manager
      const manager = await User.findById(userId);
      if (manager && manager.referredBy) {
        query.owner = manager.referredBy;
      } else {
        return res.status(403).json({ message: "Access denied" });
      }
    }
    
    const project = await Project.findOne(query)
      .populate({
        path: 'stages',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .populate('owner', 'name email');
    
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Format dates
    const formattedProject = {
      ...project.toObject(),
      created_at: formatDateToLocal(project.created_at),
      stages: project.stages.map(stage => ({
        ...stage.toObject(),
        start_date: formatDateToLocal(stage.start_date),
        completion_date: formatDateToLocal(stage.completion_date)
      }))
    };
    
    res.status(200).json(formattedProject);
  } catch (error) {
    console.error("Error fetching project:", error);
    res.status(500).json({ message: "Error fetching project", error });
  }
};



// Add this function to handle project status updates
export const updateProjectStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    console.log("Updating project status:", { id, status }); // Debug log
    
    // Check if user has permission to update this project
    const project = await Project.findById(id);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can update projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Validate status
    const validStatuses = ['Pending', 'Ongoing', 'Completed', 'Archived'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ message: "Invalid status value" });
    }
    
    // Update project status
    project.status = status;
    await project.save();
    
    // Format date to YYYY-MM-DD for frontend in local timezone
    const formattedProject = {
      ...project.toObject(),
      created_at: formatDateToLocal(project.created_at)
    };
    
    res.status(200).json(formattedProject);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating project status", error });
  }
};



// Update a project
// backend/controllers/project.js
// Update the updateProject function to handle status updates

export const updateProject = async (req, res) => {
  const { id } = req.params;
  const { project_name, description, status, created_at } = req.body;
  const userId = req.user._id;
  const userRole = req.user.role;
  
  try {
    console.log("Updating project:", { id, project_name, description, status, created_at });
    
    // Check if user has permission to update this project
    const project = await Project.findById(id);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can update projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Build update object dynamically based on provided fields
    const updateData = {};
    if (project_name) updateData.project_name = project_name;
    if (description !== undefined) updateData.description = description;
    if (status) updateData.status = status;
    if (created_at) {
      // Create a Date object at noon to avoid timezone issues
      updateData.created_at = createLocalDate(created_at);
    }
    
    const updatedProject = await Project.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    ).populate({
      path: 'stages',
      populate: {
        path: 'stage',
        model: 'Stage'
      }
    }).populate('owner', 'name email');
    
    if (!updatedProject) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Format date to YYYY-MM-DD for frontend in local timezone
    const formattedProject = {
      ...updatedProject.toObject(),
      created_at: formatDateToLocal(updatedProject.created_at)
    };
    
    res.status(200).json(formattedProject);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating project", error });
  }
};

// Delete a project
export const deleteProject = async (req, res) => {
  const { id } = req.params;
  const userId = req.user._id;
  const userRole = req.user.role;
  
  try {
    // Check if user has permission to delete this project
    const project = await Project.findById(id);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can delete projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Delete all project stages and connections
    await ProjectStage.deleteMany({ project: id });
    await StageConnection.deleteMany({ project: id });
    
    const deletedProject = await Project.findByIdAndDelete(id);
    
    if (!deletedProject) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    res.status(200).json({ message: "Project deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error deleting project", error });
  }
};


// Add a helper function to update project status based on stages
// const updateProjectStatusBasedOnStages = async (projectId) => {
//   try {
//     // Get all stages for the project
//     const projectStages = await ProjectStage.find({ project: projectId });
    
//     if (projectStages.length === 0) {
//       // If no stages, set status to Pending
//       await Project.findByIdAndUpdate(projectId, { status: "Pending" });
//       return;
//     }
    
//     // Check if all stages are completed
//     const allCompleted = projectStages.every(stage => stage.status === 'Completed');
    
//     // Check if any stage is ongoing
//     const anyOngoing = projectStages.some(stage => stage.status === 'Ongoing');
    
//     let newStatus;
//     if (allCompleted) {
//       newStatus = "Completed";
//     } else if (anyOngoing) {
//       newStatus = "Ongoing";
//     } else {
//       newStatus = "Pending";
//     }
    
//     await Project.findByIdAndUpdate(projectId, { status: newStatus });
//   } catch (error) {
//     console.error("Error updating project status:", error);
//   }
// };

const updateProjectStatusBasedOnStages = async (projectId) => {
  try {
    // Get all stages for the project
    const projectStages = await ProjectStage.find({ project: projectId });
    
    if (projectStages.length === 0) {
      // If no stages, set status to Pending
      await Project.findByIdAndUpdate(projectId, { status: "Pending" });
      return;
    }
    
    // Check if any stage is ongoing
    const anyOngoing = projectStages.some(stage => stage.status === 'Ongoing');
    
    // Check if all stages are completed
    const allCompleted = projectStages.every(stage => stage.status === 'Completed');
    
    let newStatus;
    if (anyOngoing) {
      newStatus = "Ongoing";
    } else if (allCompleted) {
      // Keep the current status if all stages are completed
      // Don't automatically change to "Completed"
      const project = await Project.findById(projectId);
      newStatus = project.status;
    } else {
      newStatus = "Pending";
    }
    
    // Only update if the status is different
    const project = await Project.findById(projectId);
    if (project.status !== newStatus) {
      await Project.findByIdAndUpdate(projectId, { status: newStatus });
    }
  } catch (error) {
    console.error("Error updating project status:", error);
  }
};



// Update the addStageToProject function
// export const addStageToProject = async (req, res) => {
//   try {
//     const { projectId } = req.params;
//     const { stageId, status, start_date, completion_date } = req.body;
//     const userId = req.user._id;
//     const userRole = req.user.role;
    
//     // Check if user has permission to add stages to this project
//     const project = await Project.findById(projectId);
//     if (!project) {
//       return res.status(404).json({ message: "Project not found" });
//     }
    
//     // Only managers can add stages to projects, and only their own projects
//     if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
//       return res.status(403).json({ message: "Access denied" });
//     }
    
//     // Get the current highest order number
//     const highestOrderStage = await ProjectStage.findOne({ project: projectId })
//       .sort({ order: -1 });
    
//     const order = highestOrderStage ? highestOrderStage.order + 1 : 1;
    
//     // Create new project stage
//     const newProjectStage = new ProjectStage({
//       project: projectId,
//       stage: stageId,
//       status,
//       // Save dates based on status
//       start_date: (status === 'Ongoing' || status === 'Completed') && start_date ? createLocalDate(start_date) : undefined,
//       completion_date: status === 'Completed' && completion_date ? createLocalDate(completion_date) : undefined,
//       order
//     });
    
//     await newProjectStage.save();
    
//     // Add stage to project
//     project.stages.push(newProjectStage._id);
//     await project.save();
    
//     // Update project status based on stages
//     await updateProjectStatusBasedOnStages(projectId);
    
//     // Populate stage details
//     const populatedStage = await ProjectStage.findById(newProjectStage._id)
//       .populate('stage');
    
//     // Format dates
//     const formattedStage = {
//       ...populatedStage.toObject(),
//       start_date: formatDateToLocal(populatedStage.start_date),
//       completion_date: formatDateToLocal(populatedStage.completion_date)
//     };
    
//     res.status(201).json(formattedStage);
//   } catch (error) {
//     console.error(error);
//     res.status(500).json({ message: "Error adding stage to project", error });
//   }
// };




// backend/controllers/project.js

// Update the addStageToProject function
export const addStageToProject = async (req, res) => {
  try {
    const { projectId } = req.params;
    const { stageId, status, start_date, completion_date } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if user has permission to add stages to this project
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can add stages to projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Get the current highest order number
    const highestOrderStage = await ProjectStage.findOne({ project: projectId })
      .sort({ order: -1 });
    
    const order = highestOrderStage ? highestOrderStage.order + 1 : 1;
    
    // Create new project stage
    const newProjectStage = new ProjectStage({
      project: projectId,
      stage: stageId,
      status,
      // Save dates based on status
      start_date: (status === 'Ongoing' || status === 'Completed') && start_date ? createLocalDate(start_date) : undefined,
      completion_date: status === 'Completed' && completion_date ? createLocalDate(completion_date) : undefined,
      order
    });
    
    await newProjectStage.save();
    
    // Add stage to project
    project.stages.push(newProjectStage._id);
    await project.save();
    
    // Update project status based on stages
    await updateProjectStatusBasedOnStages(projectId);
    
    // Populate stage details
    const populatedStage = await ProjectStage.findById(newProjectStage._id)
      .populate('stage');
    
    // Format dates
    const formattedStage = {
      ...populatedStage.toObject(),
      start_date: formatDateToLocal(populatedStage.start_date),
      completion_date: formatDateToLocal(populatedStage.completion_date)
    };
    
    res.status(201).json(formattedStage);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error adding stage to project", error });
  }
};




// Update the updateProjectStage function
// export const updateProjectStage = async (req, res) => {
//   try {
//     const { projectId, stageId } = req.params;
//     const { status, start_date, completion_date } = req.body;
//     const userId = req.user._id;
//     const userRole = req.user.role;
    
//     // Check if user has permission to update stages in this project
//     const project = await Project.findById(projectId);
//     if (!project) {
//       return res.status(404).json({ message: "Project not found" });
//     }
    
//     // Only managers can update stages in projects, and only their own projects
//     if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
//       return res.status(403).json({ message: "Access denied" });
//     }
    
//     const projectStage = await ProjectStage.findOne({ 
//       _id: stageId, 
//       project: projectId 
//     });
    
//     if (!projectStage) {
//       return res.status(404).json({ message: "Project stage not found" });
//     }
    
//     // Update fields
//     if (status) projectStage.status = status;
    
//     // Update dates based on status
//     if (status === 'Ongoing') {
//       if (start_date) projectStage.start_date = createLocalDate(start_date);
//       // Clear completion date when changing to ongoing
//       projectStage.completion_date = undefined;
//     } else if (status === 'Completed') {
//       // For completed status, both dates are required
//       if (start_date) projectStage.start_date = createLocalDate(start_date);
//       if (completion_date) projectStage.completion_date = createLocalDate(completion_date);
//     }
    
//     await projectStage.save();
    
//     // Update project status based on stages
//     await updateProjectStatusBasedOnStages(projectId);
    
//     // Populate stage details
//     const populatedStage = await ProjectStage.findById(projectStage._id)
//       .populate('stage');
    
//     // Format dates
//     const formattedStage = {
//       ...populatedStage.toObject(),
//       start_date: formatDateToLocal(populatedStage.start_date),
//       completion_date: formatDateToLocal(populatedStage.completion_date)
//     };
    
//     res.status(200).json(formattedStage);
//   } catch (error) {
//     console.error(error);
//     res.status(500).json({ message: "Error updating project stage", error });
//   }
// };




// backend/controllers/project.js

// Update the updateProjectStage function
export const updateProjectStage = async (req, res) => {
  try {
    const { projectId, stageId } = req.params;
    const { status, start_date, completion_date } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if user has permission to update stages in this project
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can update stages in projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    const projectStage = await ProjectStage.findOne({ 
      _id: stageId, 
      project: projectId 
    });
    
    if (!projectStage) {
      return res.status(404).json({ message: "Project stage not found" });
    }
    
    // Update fields
    if (status) projectStage.status = status;
    
    // Update dates based on status
    if (status === 'Ongoing') {
      if (start_date) projectStage.start_date = createLocalDate(start_date);
      // Clear completion date when changing to ongoing
      projectStage.completion_date = undefined;
    } else if (status === 'Completed') {
      // For completed status, both dates are required
      if (start_date) projectStage.start_date = createLocalDate(start_date);
      if (completion_date) projectStage.completion_date = createLocalDate(completion_date);
    }
    
    await projectStage.save();
    
    // Update project status based on stages
    await updateProjectStatusBasedOnStages(projectId);
    
    // Populate stage details
    const populatedStage = await ProjectStage.findById(projectStage._id)
      .populate('stage');
    
    // Format dates
    const formattedStage = {
      ...populatedStage.toObject(),
      start_date: formatDateToLocal(populatedStage.start_date),
      completion_date: formatDateToLocal(populatedStage.completion_date)
    };
    
    res.status(200).json(formattedStage);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating project stage", error });
  }
};
// Update the deleteProjectStage function
export const deleteProjectStage = async (req, res) => {
  try {
    const { projectId, stageId } = req.params;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if user has permission to delete stages from this project
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can delete stages from projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    const projectStage = await ProjectStage.findOne({ 
      _id: stageId, 
      project: projectId 
    });
    
    if (!projectStage) {
      return res.status(404).json({ message: "Project stage not found" });
    }
    
    // Delete all connections related to this stage
    await StageConnection.deleteMany({ 
      $or: [
        { from_stage: stageId },
        { to_stage: stageId }
      ]
    });
    
    // Remove stage from project
    await Project.findByIdAndUpdate(projectId, {
      $pull: { stages: stageId }
    });
    
    // Delete the stage
    await ProjectStage.findByIdAndDelete(stageId);
    
    // Update project status based on remaining stages
    await updateProjectStatusBasedOnStages(projectId);
    
    res.status(200).json({ message: "Project stage deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error deleting project stage", error });
  }
};








// Create a connection between stages
export const createStageConnection = async (req, res) => {
  try {
    const { projectId } = req.params;
    const { fromStageId, toStageId } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if user has permission to create connections in this project
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Only managers can create connections in projects, and only their own projects
    if (userRole !== "manager" || project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }
    
    // Check if both stages exist and belong to the project
    const fromStage = await ProjectStage.findOne({ 
      _id: fromStageId, 
      project: projectId 
    });
    
    const toStage = await ProjectStage.findOne({ 
      _id: toStageId, 
      project: projectId 
    });
    
    if (!fromStage || !toStage) {
      return res.status(404).json({ message: "One or both stages not found" });
    }
    
    // Check if connection already exists
    const existingConnection = await StageConnection.findOne({
      from_stage: fromStageId,
      to_stage: toStageId,
      project: projectId
    });
    
    if (existingConnection) {
      return res.status(400).json({ message: "Connection already exists" });
    }
    
    // Create new connection
    const newConnection = new StageConnection({
      from_stage: fromStageId,
      to_stage: toStageId,
      project: projectId
    });
    
    await newConnection.save();
    
    // Add connection to both stages
    fromStage.connections.push(newConnection._id);
    toStage.connections.push(newConnection._id);
    
    await fromStage.save();
    await toStage.save();
    
    res.status(201).json(newConnection);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error creating stage connection", error });
  }
};

// Get all connections for a project
export const getProjectStageConnections = async (req, res) => {
  try {
    const { projectId } = req.params;
    const userId = req.user._id;
    const userRole = req.user.role;
    
    // Check if user has permission to view connections for this project
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can only access their own projects
      if (project.owner.toString() !== userId.toString()) {
        return res.status(403).json({ message: "Access denied" });
      }
    } else if (userRole === "user") {
      // Users can only access projects of their manager
      const manager = await User.findById(userId);
      if (!manager || !manager.referredBy || project.owner.toString() !== manager.referredBy.toString()) {
        return res.status(403).json({ message: "Access denied" });
      }
    }
    
    const connections = await StageConnection.find({ project: projectId })
      .populate({
        path: 'from_stage',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .populate({
        path: 'to_stage',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      });
    
    res.status(200).json(connections);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error fetching stage connections", error });
  }
};

// Get available years from projects
export const getProjectYears = async (req, res) => {
  try {
    const userId = req.user._id;
    const userRole = req.user.role;
    
    let query = {};
    
    // Role-based access control
    if (userRole === "manager") {
      // Managers can see their own projects
      query.owner = userId;
    } else if (userRole === "user") {
      // Users can see projects of their manager
      const manager = await User.findById(userId);
      if (manager && manager.referredBy) {
        query.owner = manager.referredBy;
      } else {
        // If user doesn't have a manager, they can't see any projects
        return res.status(200).json([]);
      }
    }
    
    // Get distinct years from project creation dates
    const projects = await Project.find(query, { created_at: 1 });
    const yearsSet = new Set();
    
    projects.forEach(project => {
      if (project.created_at) {
        const year = new Date(project.created_at).getFullYear();
        yearsSet.add(year);
      }
    });
    
    const years = Array.from(yearsSet).sort((a, b) => b - a); // Sort in descending order
    
    console.log("Available years:", years); // Debug log
    
    res.status(200).json(years);
  } catch (error) {
    console.error("Error fetching project years:", error);
    res.status(500).json({ message: "Error fetching project years", error: error.message });
  }
};




\\backend/controllers/stage.js
import Stage from "../models/stage.js";
import Project from "../models/project.js";
import ProjectStage from "../models/projectStage.js";

// Create a new stage (can be global or project-specific)
export const createStage = async (req, res) => {
  try {
    const { stage_name, description, isCustom, projectId } = req.body;
    const userId = req.user._id;
    const userRole = req.user.role;

    // Only managers can create stages
    if (userRole !== "manager") {
      return res.status(403).json({ success: false, error: "Only managers can create stages" });
    }

    // If it's a custom stage for a specific project, verify the project exists and user owns it
    if (isCustom && projectId) {
      const project = await Project.findById(projectId);
      if (!project) {
        return res.status(404).json({ success: false, error: "Project not found" });
      }
      
      if (project.owner.toString() !== userId.toString()) {
        return res.status(403).json({ success: false, error: "You can only add custom stages to your own projects" });
      }
    }

    const newStage = new Stage({
      stage_name,
      description,
      owner: userId,
      isCustom: isCustom || false,
      projectSpecific: isCustom ? projectId : null,
    });

    await newStage.save();
    res.status(201).json({ success: true, stage: newStage });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ success: false, error: "Server error" });
  }
};

// Get all stages (global and project-specific if projectId is provided)
export const getAllStages = async (req, res) => {
  try {
    const { projectId } = req.query;
    const userId = req.user._id;
    const userRole = req.user.role;

    let query = { isCustom: false }; // Default to global stages

    // If projectId is provided and user is a manager, include custom stages for that project
    if (projectId && userRole === "manager") {
      // Verify the project exists and user owns it
      const project = await Project.findById(projectId);
      if (project && project.owner.toString() === userId.toString()) {
        query = {
          $or: [
            { isCustom: false },
            { isCustom: true, projectSpecific: projectId }
          ]
        };
      }
    }

    const stages = await Stage.find(query)
      .populate('owner', 'name email')
      .sort({ createdAt: -1 });

    res.status(200).json(stages);
  } catch (error) {
    console.error("Error fetching stages:", error);
    res.status(500).json({ message: "Error fetching stages", error: error.message });
  }
};

// Get a single stage by ID
export const getStageById = async (req, res) => {
  try {
    const { id } = req.params;
    const stage = await Stage.findById(id).populate('owner', 'name email');
    
    if (!stage) {
      return res.status(404).json({ message: "Stage not found" });
    }
    
    res.status(200).json(stage);
  } catch (error) {
    console.error("Error fetching stage:", error);
    res.status(500).json({ message: "Error fetching stage", error });
  }
};

// Update a stage
export const updateStage = async (req, res) => {
  try {
    const { id } = req.params;
    const { stage_name, description } = req.body;
    const userId = req.user._id;

    const stage = await Stage.findById(id);
    if (!stage) {
      return res.status(404).json({ message: "Stage not found" });
    }

    // Only the owner can update the stage
    if (stage.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }

    stage.stage_name = stage_name;
    stage.description = description;
    await stage.save();

    res.status(200).json(stage);
  } catch (error) {
    console.error("Error updating stage:", error);
    res.status(500).json({ message: "Error updating stage", error });
  }
};

// Delete a stage
export const deleteStage = async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;

    const stage = await Stage.findById(id);
    if (!stage) {
      return res.status(404).json({ message: "Stage not found" });
    }

    // Only the owner can delete the stage
    if (stage.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }

    // Check if the stage is being used in any project
    const projectStages = await ProjectStage.find({ "stage._id": id });
    if (projectStages.length > 0) {
      return res.status(400).json({ 
        message: "Cannot delete stage that is being used in projects" 
      });
    }

    await Stage.findByIdAndDelete(id);
    res.status(200).json({ message: "Stage deleted successfully" });
  } catch (error) {
    console.error("Error deleting stage:", error);
    res.status(500).json({ message: "Error deleting stage", error });
  }
};

// Delete a custom stage from a specific project (also removes from database)

// Add this new function (keep all existing functions)
// Keep all existing functions and update the delete function name
export const deleteCustomStageFromProject = async (req, res) => {
  try {
    const { stageId, projectId } = req.body;
    const userId = req.user._id;

    // Verify the project exists and user owns it
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    if (project.owner.toString() !== userId.toString()) {
      return res.status(403).json({ message: "Access denied" });
    }

    // Verify the stage exists and is a custom stage for this project
    const stage = await Stage.findById(stageId);
    if (!stage) {
      return res.status(404).json({ message: "Stage not found" });
    }

    if (!stage.isCustom || stage.projectSpecific?.toString() !== projectId) {
      return res.status(400).json({ 
        message: "Can only delete custom stages specific to this project" 
      });
    }

    // Remove the stage from any project stages that might be using it
    await ProjectStage.deleteMany({ "stage._id": stageId });

    // Delete the stage from the database
    await Stage.findByIdAndDelete(stageId);

    res.status(200).json({ message: "Custom stage deleted successfully" });
  } catch (error) {
    console.error("Error deleting custom stage:", error);
    res.status(500).json({ message: "Error deleting custom stage", error: error.message });
  }
};








\\backend/controllers/user.js

import User from "../models/user.js";
import bcrypt from "bcrypt";

const getUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user._id).select("-password");
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    // If user is a regular user, hide the manager's email
    const userData = user.toObject();
    if (userData.role === "user") {
      delete userData.manager;
    }
    
    res.status(200).json(userData);
  } catch (error) {
    console.error("Error fetching user profile:", error);
    res.status(500).json({ message: "Server error" });
  }
};

const updateUserProfile = async (req, res) => {
  try {
    const { name, profilePicture } = req.body;
    const user = await User.findById(req.user._id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    user.name = name;
    user.profilePicture = profilePicture;
    await user.save();
    
    // If user is a regular user, hide the manager's email
    const userData = user.toObject();
    if (userData.role === "user") {
      delete userData.manager;
    }
    
    res.status(200).json(userData);
  } catch (error) {
    console.error("Error updating user profile:", error);
    res.status(500).json({ message: "Server error" });
  }
};

const changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword, confirmPassword } = req.body;
    const user = await User.findById(req.user._id).select("+password");
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    
    if (newPassword !== confirmPassword) {
      return res
        .status(400)
        .json({ message: "New password and confirm password do not match" });
    }
    
    const isPasswordValid = await bcrypt.compare(
      currentPassword,
      user.password
    );
    if (!isPasswordValid) {
      return res.status(403).json({ message: "Invalid old password" });
    }
    
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();
    
    res.status(200).json({ message: "Password updated successfully" });
  } catch (error) {
    console.error("Error changing password:", error);
    res.status(500).json({ message: "Server error" });
  }
};

export { getUserProfile, updateUserProfile, changePassword };







\\backend\controller\userManagement.js



import User from "../models/user.js";

const getReferredUsers = async (req, res) => {
  try {
    const managerId = req.user._id;
    const referredUsers = await User.find({ referredBy: managerId }).select("-password");
    
    res.status(200).json(referredUsers);
  } catch (error) {
    console.error("Error fetching referred users:", error);
    res.status(500).json({ message: "Server error" });
  }
};

const toggleUserStatus = async (req, res) => {
  try {
    const { userId } = req.params;
    const managerId = req.user._id;
    
    // Check if the user to be updated is referred by the current manager
    const user = await User.findOne({ _id: userId, referredBy: managerId });
    
    if (!user) {
      return res.status(404).json({ message: "User not found or not referred by you" });
    }
    
    user.isActive = !user.isActive;
    await user.save();
    
    res.status(200).json({ 
      message: `User ${user.isActive ? 'activated' : 'deactivated'} successfully`,
      isActive: user.isActive 
    });
  } catch (error) {
    console.error("Error toggling user status:", error);
    res.status(500).json({ message: "Server error" });
  }
};

const getReferralLink = async (req, res) => {
  try {
    const manager = await User.findById(req.user._id);
    
    if (!manager.referralLink) {
      // Generate referral link if it doesn't exist
      manager.referralLink = `${process.env.FRONTEND_URL}/sign-up?ref=${manager._id}`;
      await manager.save();
    }
    
    res.status(200).json({ referralLink: manager.referralLink });
  } catch (error) {
    console.error("Error getting referral link:", error);
    res.status(500).json({ message: "Server error" });
  }
};

export {
  getReferredUsers,
  toggleUserStatus,
  getReferralLink
};







\\backend\libs\arcjet

import arcjet, {
  detectBot,
  shield,
  tokenBucket,
  validateEmail,
} from "@arcjet/node";

const aj = arcjet({
  // Get your site key from https://app.arcjet.com and set it as an environment
  // variable rather than hard coding.
  key: process.env.ARCJET_KEY,
  characteristics: ["ip.src"], // Track requests by IP
  rules: [
    // Shield protects your app from common attacks e.g. SQL injection
    shield({ mode: "LIVE" }),
    // Create a bot detection rule
    detectBot({
      mode: "LIVE", // Blocks requests. Use "DRY_RUN" to log only
      // Block all bots except the following
      allow: [
        "CATEGORY:SEARCH_ENGINE", // Google, Bing, etc
        // Uncomment to allow these other common bot categories
        // See the full list at https://arcjet.com/bot-list
        //"CATEGORY:MONITOR", // Uptime monitoring services
        //"CATEGORY:PREVIEW", // Link previews e.g. Slack, Discord
      ],
    }),
    validateEmail({
      mode: "LIVE", // will block requests. Use "DRY_RUN" to log only
      // block disposable, invalid, and email addresses with no MX records
      deny: ["DISPOSABLE", "INVALID", "NO_MX_RECORDS"],
    }),
    // Create a token bucket rate limit. Other algorithms are supported.
    tokenBucket({
      mode: "LIVE",
      refillRate: 5, // Refill 5 tokens per interval
      interval: 10, // Refill every 10 seconds
      capacity: 10, // Bucket capacity of 10 tokens
    }),
  ],
});

export default aj;




\\backend\index.js

const mongoose = require('mongoose');
require('dotenv').config();

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected successfully');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }
};

module.exports = { connectDB };








// backend/libs/pdf-generator.js
import puppeteer from 'puppeteer';
import fs from 'fs';
import path from 'path';
import os from 'os';

export const generateProjectPDF = async (projectData) => {
  try {
    console.log("Generating PDF for project:", projectData.project_name);
    
    // Create a temporary HTML file for the PDF content
    const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Project Details - ${projectData.project_name}</title>
        <style>
          body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
          }
          .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
          }
          .project-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
          }
          .project-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
          }
          .info-item {
            margin-bottom: 10px;
          }
          .info-label {
            font-weight: bold;
            color: #34495e;
          }
          .stages-section {
            margin-top: 30px;
          }
          .section-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
          }
          .stage-card {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            background-color: #f9f9f9;
          }
          .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
          }
          .stage-name {
            font-weight: bold;
            font-size: 16px;
          }
          .stage-status {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
          }
          .status-ongoing {
            background-color: #3498db;
          }
          .status-completed {
            background-color: #2ecc71;
          }
          .stage-description {
            margin-bottom: 10px;
            color: #555;
          }
          .stage-dates {
            font-size: 14px;
            color: #777;
          }
          .stage-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
          }
          .stage-table th, .stage-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
          }
          .stage-table th {
            background-color: #f2f2f2;
            font-weight: bold;
          }
          .stage-table tr:nth-child(even) {
            background-color: #f9f9f9;
          }
          .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
            color: #777;
            border-top: 1px solid #eee;
            padding-top: 10px;
          }
        </style>
      </head>
      <body>
        <div class="header">
          <h1 class="project-title">${projectData.project_name}</h1>
          <p>Project Details Report</p>
        </div>
        
        <div class="project-info">
          <div>
            <div class="info-item">
              <span class="info-label">Description:</span> ${projectData.description || 'No description provided'}
            </div>
            <div class="info-item">
              <span class="info-label">Status:</span> ${projectData.status}
            </div>
            <div class="info-item">
              <span class="info-label">Created At:</span> ${new Date(projectData.created_at).toLocaleDateString()}
            </div>
            <div class="info-item">
              <span class="info-label">Owner:</span> ${projectData.owner.name}
            </div>
          </div>
        </div>
        
        <div class="stages-section">
          <h2 class="section-title">Project Stages</h2>
          
          <!-- Stage Table View -->
          <table class="stage-table">
            <thead>
              <tr>
                <th>Stage Name</th>
                <th>Description</th>
                <th>Status</th>
                <th>Start Date</th>
                <th>Completion Date</th>
              </tr>
            </thead>
            <tbody>
              ${projectData.stages && projectData.stages.length > 0 ? projectData.stages.map(stage => `
                <tr>
                  <td>${stage.stage.stage_name}</td>
                  <td>${stage.stage.description || 'No description'}</td>
                  <td>
                    <span class="stage-status status-${stage.status.toLowerCase()}">${stage.status}</span>
                  </td>
                  <td>${stage.start_date ? new Date(stage.start_date).toLocaleDateString() : 'Not set'}</td>
                  <td>${stage.completion_date ? new Date(stage.completion_date).toLocaleDateString() : 'Not set'}</td>
                </tr>
              `).join('') : '<tr><td colspan="5" style="text-align: center;">No stages found</td></tr>'}
            </tbody>
          </table>
          
          <!-- Stage Card View -->
          <div style="margin-top: 30px;">
            ${projectData.stages && projectData.stages.length > 0 ? projectData.stages.map(stage => `
              <div class="stage-card">
                <div class="stage-header">
                  <div class="stage-name">${stage.stage.stage_name}</div>
                  <span class="stage-status status-${stage.status.toLowerCase()}">${stage.status}</span>
                </div>
                ${stage.stage.description ? `<div class="stage-description">${stage.stage.description}</div>` : ''}
                <div class="stage-dates">
                  <div><strong>Start Date:</strong> ${stage.start_date ? new Date(stage.start_date).toLocaleDateString() : 'Not set'}</div>
                  ${stage.completion_date ? `<div><strong>Completion Date:</strong> ${new Date(stage.completion_date).toLocaleDateString()}</div>` : ''}
                </div>
              </div>
            `).join('') : '<p style="text-align: center;">No stages found</p>'}
          </div>
        </div>
        
        <div class="footer">
          <p>Generated on ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}</p>
          <p>© 2025 TaskHub Project Management System</p>
        </div>
      </body>
      </html>
    `;

    // Create a temporary file
    const tempDir = os.tmpdir();
    const fileName = `project-${projectData._id}-${Date.now()}.pdf`;
    const filePath = path.join(tempDir, fileName);

    console.log("Generating PDF at path:", filePath);

    // Launch Puppeteer with error handling
    let browser;
    try {
      browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
      });
      
      const page = await browser.newPage();
      await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
      
      // Generate PDF
      await page.pdf({
        path: filePath,
        format: 'A4',
        printBackground: true,
        margin: {
          top: '20mm',
          right: '20mm',
          bottom: '20mm',
          left: '20mm'
        }
      });
      
      console.log("PDF generated successfully");
    } catch (browserError) {
      console.error("Error with Puppeteer:", browserError);
      throw new Error(`Failed to generate PDF: ${browserError.message}`);
    } finally {
      if (browser) {
        await browser.close();
      }
    }
    
    return {
      filePath,
      fileName
    };
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
};







// backend/libs/send-email.js
import nodemailer from 'nodemailer';
import fs from 'fs';
import dotenv from 'dotenv';
dotenv.config();

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

export const sendEmail = async (to, subject, html) => {
  const mailOptions = {
    from: `TaskHub <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
  };
  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('✅ Email sent:', info.response);
    return true;
  } catch (error) {
    console.error('❌ Error sending email:', error);
    return false;
  }
};

export const sendEmailWithAttachment = async (to, subject, html, attachmentPath, fileName) => {
  // Check if attachment file exists
  if (!fs.existsSync(attachmentPath)) {
    console.error('❌ Attachment file not found:', attachmentPath);
    return false;
  }

  const mailOptions = {
    from: `TaskHub <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
    attachments: [
      {
        filename: fileName,
        path: attachmentPath,
      },
    ],
  };
  try {
    const info = await transporter.sendMail(mailOptions);
    console.log('✅ Email with attachment sent:', info.response);
    return true;
  } catch (error) {
    console.error('❌ Error sending email with attachment:', error);
    return false;
  }
};








\\backend\libs\validate-schemas.js

import { z } from "zod";

const registerSchema = z.object({
  name: z.string().min(3, "Name is required"),
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
  managerId: z.string().optional(),
});

const loginSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(1, "Password is required"),
});

const verifyEmailSchema = z.object({
  token: z.string().min(1, "Token is required"),
});

const resetPasswordSchema = z.object({
  token: z.string().min(1, "Token is required"),
  newPassword: z.string().min(8, "Password must be at least 8 characters long"),
  confirmPassword: z.string().min(1, "Confirm password is required"),
});

const emailSchema = z.object({
  email: z.string().email("Invalid email address"),
});

const inviteMemberSchema = z.object({
  email: z.string().email("Invalid email address"),
  role: z.enum(["admin", "member", "viewer"]),
});

const tokenSchema = z.object({
  token: z.string().min(1, "Token is required"),
});

const workspaceSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  color: z.string().min(1, "Color is required"),
});

const taskSchema = z.object({
  title: z.string().min(1, "Task title is required"),
  description: z.string().optional(),
  status: z.enum(["To Do", "In Progress", "Done"]),
  priority: z.enum(["Low", "Medium", "High"]),
  dueDate: z.string().min(1, "Due date is required"),
  assignees: z.array(z.string()).min(1, "At least one assignee is required"),
});

// Project schemas
export const projectSchema = z.object({
  project_name: z.string().min(3).max(255),
  description: z.string().max(1000).optional(),
  status: z.enum(["Pending", "Ongoing", "Completed", "Archived"]).default("Pending"),
  created_at: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  user_id: z.number().positive(),
});

export const projectIdSchema = z.object({
  id: z.string().transform((val) => parseInt(val, 10)),
});

export const updateProjectSchema = z.object({
  project_name: z.string().min(3).max(255).optional(),
  description: z.string().max(1000).optional(),
  status: z.enum(["Pending", "Ongoing", "Completed", "Archived"]).optional(),
  created_at: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
}).refine((data) => Object.keys(data).length > 0, {
  message: "At least one field must be provided for update",
});

export {
  registerSchema,
  loginSchema,
  verifyEmailSchema,
  resetPasswordSchema,
  emailSchema,
  workspaceSchema,
  taskSchema,
  inviteMemberSchema,
  tokenSchema,
};






\\backend\middleware\auth-middleware.js

import jwt from "jsonwebtoken";
import User from "../models/user.js";

const authMiddleware = async (req, res, next) => {
  try {
    const token = req.headers.authorization?.split(" ")[1]; //Bearer dhghjhdkjfg
    if (!token) {
      return res.status(401).json({
        message: "Unauthorized",
      });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);
    
    if (!user) {
      return res.status(401).json({
        message: "Unauthorized",
      });
    }
    
    // Add user role and manager information to the request
    req.user = user;
    next();
  } catch (error) {
    console.log(error);
    res.status(500).json({
      message: "Internal server error",
    });
  }
};

export default authMiddleware;





// backend/models/customProjectStage.js
import mongoose, { Schema } from "mongoose";

const customProjectStageSchema = new Schema(
  {
    project: {
      type: Schema.Types.ObjectId,
      ref: "Project",
      required: true,
    },
    stage_name: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    status: {
      type: String,
      enum: ["Ongoing", "Completed"],
      default: "Ongoing",
    },
    start_date: {
      type: Date,
    },
    completion_date: {
      type: Date,
    },
    order: {
      type: Number,
      default: 0,
    },
    created_by: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
  },
  { timestamps: true }
);

const CustomProjectStage = mongoose.model("CustomProjectStage", customProjectStageSchema);
export default CustomProjectStage;







\\backend\models\email.js

import mongoose, { Schema } from "mongoose";

const emailSchema = new Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    owner: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
  },
  { timestamps: true }
);

const Email = mongoose.model("Email", emailSchema);

export default Email;








\\backend\models\project.js
import mongoose, { Schema } from "mongoose";

const projectSchema = new Schema(
  {
    project_name: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    status: {
      type: String,
      enum: ["Pending", "Ongoing", "Completed", "Archived"],
      default: "Pending",
    },
    created_at: {
      type: Date,
      required: true,
    },
    owner: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    sharedWith: [{
      type: Schema.Types.ObjectId,
      ref: "User"
    }],
    stages: [
      {
        type: Schema.Types.ObjectId,
        ref: "ProjectStage",
      },
    ],
  },
  { timestamps: true }
);

const Project = mongoose.model("Project", projectSchema);

export default Project;







\\backend\models\projectStage.js

import mongoose, { Schema } from "mongoose";

const projectStageSchema = new Schema(
  {
    project: {
      type: Schema.Types.ObjectId,
      ref: "Project",
      required: true,
    },
    stage: {
      type: Schema.Types.ObjectId,
      ref: "Stage",
      required: true,
    },
    status: {
      type: String,
      enum: ["Ongoing", "Completed"],
      default: "Ongoing",
    },
    start_date: {
      type: Date,
    },
    completion_date: {
      type: Date,
    },
    order: {
      type: Number,
      default: 0,
    },
  },
  { timestamps: true }
);

const ProjectStage = mongoose.model("ProjectStage", projectStageSchema);
export default ProjectStage;








\\backend\models\stage.js
import mongoose, { Schema } from "mongoose";

const stageSchema = new Schema(
  {
    stage_name: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
      trim: true,
    },
    owner: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    isCustom: {
      type: Boolean,
      default: false,
    },
    projectSpecific: {
      type: Schema.Types.ObjectId,
      ref: "Project",
      default: null,
    },
  },
  { timestamps: true }
);

const Stage = mongoose.model("Stage", stageSchema);
export default Stage;




// backend/models/stageConnection.js
import mongoose from "mongoose";

const stageConnectionSchema = new mongoose.Schema({
  from_stage: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "ProjectStage",
    required: true
  },
  to_stage: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "ProjectStage",
    required: true
  },
  project: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Project",
    required: true
  }
}, { timestamps: true });

const StageConnection = mongoose.model("StageConnection", stageConnectionSchema);
export default StageConnection;







\\backend\models\user.js
import mongoose, { Schema } from "mongoose";

const userSchema = new Schema(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: { type: String, required: true, select: false },
    name: { type: String, required: true, trim: true },
    profilePicture: { type: String },
    isEmailVerified: { type: Boolean, default: false },
    lastLogin: { type: Date },
    is2FAEnabled: { type: Boolean, default: false },
    twoFAOtp: { type: String, select: false },
    twoFAOtpExpires: { type: Date, select: false },
    role: {
      type: String,
      enum: ["manager", "user"],
      default: "manager",
    },
    referredBy: {
      type: Schema.Types.ObjectId,
      ref: "User",
      default: null,
    },
    referralLink: {
      type: String,
      unique: true,
      sparse: true,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  { timestamps: true }
);

// Generate referral link before saving
userSchema.pre("save", function (next) {
  if (this.role === "manager" && !this.referralLink) {
    this.referralLink = `${process.env.FRONTEND_URL}/sign-up?ref=${this._id}`;
  }
  next();
});

const User = mongoose.model("User", userSchema);

export default User;







\\backend\models\verification.js

import mongoose from "mongoose";

const verificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    token: {
      type: String,
      required: true,
    },
    expiresAt: {
      type: Date,
      required: true,
    },
  },
  { timestamps: true }
);

const Verification = mongoose.model("Verification", verificationSchema);

export default Verification;







\\backend\routes\auth.js
import express from "express";
import { z } from "zod";
import { validateRequest } from "zod-express-middleware";
import {
  emailSchema,
  loginSchema,
  registerSchema,
  resetPasswordSchema,
  verifyEmailSchema,
} from "../libs/validate-schema.js";
import {
  loginUser,
  registerUser,
  resetPasswordRequest,
  verifyEmail,
  verifyResetPasswordTokenAndResetPassword,
} from "../controllers/auth-controller.js";

const router = express.Router();

router.post(
  "/register",
  validateRequest({
    body: registerSchema,
  }),
  registerUser
);

router.post(
  "/login",
  validateRequest({
    body: loginSchema,
  }),
  loginUser
);

router.post(
  "/verify-email",
  validateRequest({
    body: verifyEmailSchema,
  }),
  verifyEmail
);

router.post(
  "/reset-password-request",
  validateRequest({
    body: emailSchema,
  }),
  resetPasswordRequest
);

router.post(
  "/reset-password",
  validateRequest({
    body: resetPasswordSchema,
  }),
  verifyResetPasswordTokenAndResetPassword
);

export default router;











// backend/routes/customProjectStage.js
import express from "express";
import authenticateUser from "../middleware/auth-middleware.js";
import {
  createCustomProjectStage,
  getCustomProjectStages,
} from "../controllers/customProjectStage.js";

const router = express.Router();

// Apply authentication middleware to all routes
router.use(authenticateUser);

router.post("/", createCustomProjectStage);
router.get("/project/:projectId", getCustomProjectStages);

export default router;










// backend/routes/email.js
import express from "express";
import {
  getAllEmails,
  addEmail,
  updateEmail,
  deleteEmail,
  shareProjectDetails
} from "../controllers/email.js";
import authenticateUser from "../middleware/auth-middleware.js";

const router = express.Router();

// Apply authentication middleware to all email routes
router.use(authenticateUser);

router.get("/all-emails", getAllEmails);
router.post("/add-email", addEmail);
router.put("/update-email/:id", updateEmail);
router.delete("/delete-email/:id", deleteEmail);
router.post("/share-project", shareProjectDetails);

export default router;
















\\backend\routes\index.js
import express from "express";
import authRoutes from "./auth.js";
import projectRoutes from "./project.js";
import userRoutes from "./user.js";
import emailRoutes from "./email.js";
import stageRoutes from "./stage.js";

const router = express.Router();

router.use("/auth", authRoutes);
router.use("/projects", projectRoutes);
router.use("/users", userRoutes);
router.use("/emails", emailRoutes);
router.use("/stages", stageRoutes);

export default router;










// backend/routes/project.js
import express from "express";
import authenticateUser from "../middleware/auth-middleware.js";
import {
  createProject,
  getAllProjects,
  getProjectById,
  updateProject,
  deleteProject,
  addStageToProject,
  updateProjectStage,
  deleteProjectStage,
  createStageConnection,
  getProjectStageConnections,
  getProjectYears,
  updateProjectStatus  // Add this import
} from "../controllers/project.js";

const router = express.Router();

// Apply authentication middleware to all project routes
router.use(authenticateUser);

router.post("/project", createProject);
router.get("/all-projects", getAllProjects);
router.get("/project-years", getProjectYears);
router.get("/:id", getProjectById);
router.put("/:id", updateProject);
router.patch("/:id/status", updateProjectStatus); // Add this route for status updates
router.delete("/delete-project/:id", deleteProject);
router.post("/:projectId/stages", addStageToProject);
router.put("/:projectId/stages/:stageId", updateProjectStage);
router.delete("/:projectId/stages/:stageId", deleteProjectStage);
router.post("/:projectId/connections", createStageConnection);
router.get("/:projectId/connections", getProjectStageConnections);

export default router;













\\backend\routes\stage.js

import express from "express";
import authenticateUser from "../middleware/auth-middleware.js";
import {
  createStage,
  getAllStages,
  getStageById,
  updateStage,
  deleteStage,
  deleteCustomStageFromProject
} from "../controllers/stage.js";

const router = express.Router();

// Apply authentication middleware to all stage routes
router.use(authenticateUser);

router.post("/add-stage", createStage);
router.get("/all-stages", getAllStages);
router.get("/:id", getStageById);
router.put("/update-stage/:id", updateStage);
router.delete("/delete-stage/:id", deleteStage);
router.post("/delete-custom-stage-from-project", deleteCustomStageFromProject); // Fixed route name

export default router;









\\backend\routs\user.js

import express from "express";
import authenticateUser from "../middleware/auth-middleware.js";
import {
  changePassword,
  getUserProfile,
  updateUserProfile,
} from "../controllers/user.js";
import {
  getReferredUsers,
  toggleUserStatus,
  getReferralLink
} from "../controllers/userManagement.js";
import { z } from "zod";
import { validateRequest } from "zod-express-middleware";

const router = express.Router();

// Profile routes
router.get("/profile", authenticateUser, getUserProfile);
router.put(
  "/profile",
  authenticateUser,
  validateRequest({
    body: z.object({
      name: z.string(),
      profilePicture: z.string().optional(),
    }),
  }),
  updateUserProfile
);
router.put(
  "/change-password",
  authenticateUser,
  validateRequest({
    body: z.object({
      currentPassword: z.string(),
      newPassword: z.string(),
      confirmPassword: z.string(),
    }),
  }),
  changePassword
);

// User management routes (for managers)
router.get("/referred-users", authenticateUser, getReferredUsers);
router.put("/users/:userId/toggle-status", authenticateUser, toggleUserStatus);
router.get("/referral-link", authenticateUser, getReferralLink);

export default router;













// backend/index.js
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import mongoose from "mongoose";
import morgan from "morgan";
import routes from "./routes/index.js";

dotenv.config();

const app = express();
// Improved CORS configuration for multiple origins
const allowedOrigins = [
  process.env.FRONTEND_URL, // Production frontend (Vercel)
  "http://localhost:5173", // Local development
  "http://localhost:3000", // Alternative local port
  "https://work-stage-tracker-final.vercel.app" // Explicit production URL
].filter(Boolean); // Remove any undefined values

const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    // Check if the origin is in the allowed list
    if (allowedOrigins.indexOf(origin) !== -1) {
      return callback(null, true);
    } else {
      return callback(new Error('Not allowed by CORS'));
    }
  },
  methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  credentials: true,
  allowedHeaders: ["Content-Type", "Authorization"],
  optionsSuccessStatus: 200,
};

// Apply CORS middleware
app.use(cors(corsOptions));

// Handle preflight requests
app.options("*", cors(corsOptions));

// Logging middleware
app.use(morgan("dev"));

// Database connection
mongoose
  .connect(process.env.MONGODB_URI)
  .then(() => console.log("✅ Database connected successfully"))
  .catch((err) => console.log("❌ Failed to connect to DB:", err));

// JSON parsing middleware
app.use(express.json());

// Root route
app.get("/", async (req, res) => {
  res.status(200).json({
    message: "Welcome to TaskHub API",
    version: "1.0.0",
    status: "Running"
  });
});

// API routes
app.use("/api-v1", routes);

// Error handling middleware
app.use((err, req, res, next) => {
  console.error("🔥 Error:", err.stack);
  res.status(500).json({ 
    message: "Internal server error",
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    message: "Route not found",
    path: req.originalUrl,
    method: req.method
  });
});

// Start server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`🚀 Server running on port ${PORT}`);
  console.log(`🌐 Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`📡 Allowed origins: ${allowedOrigins.join(', ')}`);
});




























































































// frontend/app/component/dashboard/Dashboard.tsx
import React, { useState, useEffect } from "react";
import { StatsCard } from "./StatsCard";
import { ProjectStatusChart } from "./ProjectStatusChart";
import { ProjectCountOverTime } from "./ProjectCountOverTime";
import { ProjectStageInfo } from "./ProjectStageInfo";
import { StageTimeTracking } from "./StageTimeTracking";
import { RecentProjects } from "./RecentProjects"; // Import the new component
import { useDashboard, type TimePeriod } from "@/hooks/useDashboard";
import { useOutletContext } from "react-router-dom";
import { 
  FolderKanban, 
  Clock, 
  CheckCircle, 
  ListTodo, 
  Loader2,
  TrendingUp,
  Calendar,
  AlertCircle,
  BarChart3
} from "lucide-react";
import { format, subMonths, startOfMonth, endOfMonth, eachMonthOfInterval, getYear } from "date-fns";
import { useProjects } from "@/hooks/use-projects";

interface DashboardContext {
  selectedProject: any;
}

const Dashboard = () => {
  const { selectedProject } = useOutletContext<DashboardContext>();
  const [timePeriod, setTimePeriod] = useState<TimePeriod>({
    type: 'month',
    value: new Date().getFullYear().toString()
  });
  
  // Get all projects, not filtered by time period
  const { projects, isLoading, error, fetchProjects, refetch } = useProjects();
  const [localSelectedProject, setLocalSelectedProject] = useState(selectedProject);
  
  // Use the useDashboard hook with all projects for the stats cards
  const {
    totalProjects,
    ongoingProjects,
    completedProjects,
    pendingProjects,
    totalStages,
    ongoingStages,
    completedStages,
    projectStatusData,
    recentProjects,
    upcomingStages,
    isLoading: dashboardLoading
  } = useDashboard(undefined, projects); // Pass undefined as time period to get all projects
  
  // Handle project selection
  const handleProjectSelect = (project: any) => {
    console.log("Dashboard handleProjectSelect:", project); // Debug log
    setLocalSelectedProject(project);
  };
  
  // Handle time period change with useCallback to prevent unnecessary re-renders
  const handleTimePeriodChange = React.useCallback((period: TimePeriod) => {
    setTimePeriod(period);
    console.log("Time period changed to:", period); // Debug log
  }, []);
  
  if (dashboardLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-64 space-y-4">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-red-600 mb-2">Error Loading Dashboard</h2>
          <p className="text-gray-600">{error}</p>
        </div>
        <button 
          onClick={() => refetch()}
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
        >
          Try Again
        </button>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <h1 className="text-2xl font-bold">Dashboard</h1>
        
        {/* <div className="text-sm text-gray-500">
          {timePeriod.type === 'year' 
            ? `Showing data for ${timePeriod.value === 'all' ? 'all years' : timePeriod.value}` 
            : `Showing data for ${timePeriod.value}`}
        </div> */}
      </div>
      
      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <StatsCard
          title="Total Projects"
          value={totalProjects}
          icon={FolderKanban}
          filterType="all"
        />
        <StatsCard
          title="Ongoing Projects"
          value={ongoingProjects}
          icon={Clock}
          description="Currently in progress"
          filterType="ongoing"
        />
        <StatsCard
          title="Completed Projects"
          value={completedProjects}
          icon={CheckCircle}
          description="Successfully finished"
          filterType="completed"
        />
        <StatsCard
          title="Pending Projects"
          value={pendingProjects}
          icon={AlertCircle}
          description="Not started yet"
          filterType="pending"
        />
      </div>
      
      {/* Charts and Project Info */}
      <div className="grid gap-4 md:grid-cols-2">
        <ProjectStatusChart data={projectStatusData} />
        <ProjectStageInfo 
          project={localSelectedProject} 
          onProjectSelect={handleProjectSelect} 
        />
      </div>
      
      {/* Recent Projects and Time-based Charts */}
      <div className="grid gap-4 md:grid-cols-2">
        <RecentProjects projects={recentProjects} /> {/* Add the RecentProjects component */}
        <ProjectCountOverTime 
          projects={projects} // Pass all projects, not filtered ones
          onTimePeriodChange={handleTimePeriodChange} 
        />
      </div>
      
      {/* Additional Time-based Chart */}
      <div className="grid gap-4 md:grid-cols-1">
        <StageTimeTracking 
          projects={recentProjects} 
          selectedProjectId={localSelectedProject?._id} 
        />
      </div>
    </div>
  );
};

export default Dashboard;








// frontend/app/component/dashboard/ProjectCountOverTime.tsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Calendar, CalendarDays } from "lucide-react";
import { format, subYears, startOfYear, endOfYear, startOfMonth, endOfMonth, eachMonthOfInterval, getYear } from "date-fns";
import { useProjects } from "@/hooks/use-projects";

interface ProjectCountData {
  name: string;
  projects: number;
}

export interface TimePeriod {
  type: 'year' | 'month';
  value: string;
}

interface ProjectCountOverTimeProps {
  projects: any[];
  onTimePeriodChange: (period: TimePeriod) => void;
}

export const ProjectCountOverTime: React.FC<ProjectCountOverTimeProps> = ({ 
  projects, 
  onTimePeriodChange 
}) => {
  const [timeRange, setTimeRange] = useState<'year' | 'month'>('year');
  const [selectedYear, setSelectedYear] = useState<string>('');
  const [availableYears, setAvailableYears] = useState<string[]>([]);
  const [dimensions, setDimensions] = React.useState({ width: 400, height: 300 });
  const { fetchProjectYears } = useProjects();
  
  // Extract unique years from the projects data
  useEffect(() => {
    if (projects && projects.length > 0) {
      const years = new Set<string>();
      projects.forEach(project => {
        if (project.created_at) {
          const projectDate = new Date(project.created_at);
          years.add(projectDate.getFullYear().toString());
        }
      });
      
      const sortedYears = Array.from(years).sort((a, b) => parseInt(b) - parseInt(a));
      setAvailableYears(sortedYears);
      
      // Set the initial selected year to the most recent year if not already set
      if (!selectedYear && sortedYears.length > 0) {
        setSelectedYear(sortedYears[0]);
      }
    }
  }, [projects, selectedYear]);
  
  // Process projects data based on selected time range - memoized to prevent recalculation
  const chartData = useMemo(() => {
    if (!projects.length || !availableYears.length) {
      return [];
    }
    
    let data: ProjectCountData[] = [];
    
    if (timeRange === 'year') {
      // Show project count per year for all available years
      const years = availableYears.map(year => parseInt(year));
      
      data = years.map(year => {
        const yearStart = startOfYear(new Date(year, 0, 1));
        const yearEnd = endOfYear(new Date(year, 0, 1));
        
        const count = projects.filter(project => {
          const projectDate = new Date(project.created_at);
          return projectDate >= yearStart && projectDate <= yearEnd;
        }).length;
        
        return {
          name: year.toString(),
          projects: count
        };
      });
    } else {
      // Show project count per month for the selected year
      if (!selectedYear) return [];
      
      const year = parseInt(selectedYear);
      const yearStart = startOfYear(new Date(year, 0, 1));
      const yearEnd = endOfYear(new Date(year, 0, 1));
      const months = eachMonthOfInterval({ start: yearStart, end: yearEnd });
      
      data = months.map(month => {
        const monthStart = startOfMonth(month);
        const monthEnd = endOfMonth(month);
        
        const count = projects.filter(project => {
          const projectDate = new Date(project.created_at);
          return projectDate >= monthStart && projectDate <= monthEnd;
        }).length;
        
        return {
          name: format(month, 'MMM'),
          projects: count
        };
      });
    }
    
    return data;
  }, [projects, timeRange, selectedYear, availableYears]);
  
  // Handle time range change - memoized to prevent unnecessary re-renders
  const handleTimeRangeChange = useCallback((value: 'year' | 'month') => {
    setTimeRange(value);
    // Create a properly typed period object
    const period: TimePeriod = { 
      type: value, 
      value: value === 'year' ? 'all' : (selectedYear || availableYears[0])
    };
    onTimePeriodChange(period);
  }, [onTimePeriodChange, selectedYear, availableYears]);
  
  // Handle year change - memoized to prevent unnecessary re-renders
  const handleYearChange = useCallback((value: string) => {
    setSelectedYear(value);
    // Create a properly typed period object
    const period: TimePeriod = { 
      type: 'month', 
      value
    };
    onTimePeriodChange(period);
  }, [onTimePeriodChange]);
  
  return (
    <Card className="w-full h-full flex flex-col overflow-hidden">
      <CardHeader className="pb-2 flex-shrink-0">
        <div className="flex flex-col space-y-4">
          <CardTitle className="text-base sm:text-lg md:text-xl flex items-center gap-2">
            <CalendarDays className="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 flex-shrink-0" />
            <span className="truncate">Projects Over Time</span>
          </CardTitle>
          
          <div className="flex flex-wrap gap-2">
            <Select value={timeRange} onValueChange={handleTimeRangeChange}>
              <SelectTrigger className="w-full sm:w-auto">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="year">By Year</SelectItem>
                <SelectItem value="month">By Month</SelectItem>
              </SelectContent>
            </Select>
            {timeRange === 'month' && (
              <Select value={selectedYear} onValueChange={handleYearChange}>
                <SelectTrigger className="w-full sm:w-auto">
                  <SelectValue placeholder="Select a year" />
                </SelectTrigger>
                <SelectContent>
                  {availableYears.map(year => (
                    <SelectItem key={year} value={year}>
                      {year}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-1 sm:p-2 md:p-4 flex-grow flex flex-col overflow-hidden">
        <div className="h-full w-full min-h-[200px]">
          {chartData.length > 0 ? (
            <ResponsiveContainer width="100%" height="100%">
              <LineChart
                data={chartData}
                margin={{
                  top: 5,
                  right: 5,
                  left: 5,
                  bottom: dimensions.width < 400 ? 25 : 5,
                }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="name" 
                  tick={{ fontSize: dimensions.width < 400 ? 8 : dimensions.width < 640 ? 10 : 12 }}
                  angle={dimensions.width < 640 ? -45 : 0}
                  textAnchor={dimensions.width < 640 ? "end" : "middle"}
                  height={dimensions.width < 640 ? 40 : 30}
                  interval={0}
                />
                <YAxis 
                  tick={{ fontSize: dimensions.width < 400 ? 8 : dimensions.width < 640 ? 10 : 12 }} 
                  width={dimensions.width < 400 ? 25 : 30} 
                />
                <Tooltip 
                  formatter={(value) => [`${value} projects`, 'Count']}
                  labelFormatter={(label) => `Period: ${label}`}
                />
                <Legend 
                  iconSize={dimensions.width < 400 ? 8 : 10}
                  iconType="circle"
                  wrapperStyle={{
                    fontSize: dimensions.width < 400 ? '8px' : dimensions.width < 640 ? '10px' : '12px',
                    paddingTop: '5px'
                  }}
                />
                <Line 
                  type="linear" 
                  dataKey="projects" 
                  stroke="#8884d8" 
                  activeDot={{ r: dimensions.width < 400 ? 4 : 6 }}
                  name="Projects"
                  strokeWidth={dimensions.width < 400 ? 1 : 1.5}
                />
              </LineChart>
            </ResponsiveContainer>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <p className="mb-2 text-sm md:text-base">No project data available</p>
                <p className="text-xs md:text-sm">Create projects to see trends over time</p>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};






// frontend/app/component/dashboard/ProjectSearchDropdown.tsx
import React, { useState, useEffect, useRef } from 'react';
import { Search, ChevronDown } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent } from "@/components/ui/card";
import { useProjects } from "@/hooks/use-projects";

interface ProjectSearchDropdownProps {
  onProjectSelect: (project: any) => void;
  selectedProject?: any;
}

export const ProjectSearchDropdown: React.FC<ProjectSearchDropdownProps> = ({ 
  onProjectSelect, 
  selectedProject 
}) => {
  const { projects } = useProjects();
  const [searchTerm, setSearchTerm] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [filteredProjects, setFilteredProjects] = useState<any[]>([]);
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  // Filter projects based on search term
  useEffect(() => {
    if (!searchTerm) {
      // Show all projects when no search term
      setFilteredProjects(projects);
      return;
    }
    
    const term = searchTerm.toLowerCase();
    const filtered = projects.filter(project =>
      project.project_name.toLowerCase().includes(term) ||
      (project.description && project.description.toLowerCase().includes(term))
    );
    
    setFilteredProjects(filtered);
  }, [searchTerm, projects]);
  
  const handleProjectClick = (project: any) => {
    onProjectSelect(project);
    setIsOpen(false);
    setSearchTerm('');
  };
  
  const clearSelection = () => {
    onProjectSelect(null);
    setSearchTerm('');
  };
  
  const getStatusColor = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className="w-full max-w-md" ref={dropdownRef}>
      <div className="relative">
        <div className="flex gap-2">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
            <Input
              placeholder="Search projects..."
              value={selectedProject ? selectedProject.project_name : searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              onFocus={() => setIsOpen(true)}
              className="pl-10 pr-10"
            />
            {selectedProject && (
              <Button
                variant="ghost"
                size="sm"
                className="absolute right-1 top-1/2 transform -translate-y-1/2 h-6 w-6 p-0"
                onClick={clearSelection}
              >
                ×
              </Button>
            )}
          </div>
          <Button 
            variant="outline" 
            onClick={() => setIsOpen(!isOpen)}
            className="flex items-center gap-1"
          >
            Select
            <ChevronDown className={`h-4 w-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
          </Button>
        </div>
        
        {isOpen && (
          <Card className="absolute z-10 w-full mt-1 shadow-lg">
            <CardContent className="p-0">
              <div className="max-h-80 overflow-y-auto">
                {filteredProjects.length === 0 ? (
                  <div className="p-4 text-center text-gray-500">
                    No projects found
                  </div>
                ) : (
                  <div className="py-1">
                    {filteredProjects.map((project) => (
                      <div
                        key={project._id}
                        className="px-4 py-3 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0"
                        onClick={() => handleProjectClick(project)}
                      >
                        <div className="flex justify-between items-start">
                          <div className="flex-1 min-w-0">
                            <div className="font-medium break-words">{project.project_name}</div>
                            {project.description && (
                              <div className="text-sm text-gray-500 mt-1 break-words">
                                {project.description}
                              </div>
                            )}
                            <div className="text-xs text-gray-400 mt-1">
                              Created: {new Date(project.created_at).toLocaleDateString()}
                            </div>
                          </div>
                          <div className="ml-2 flex-shrink-0">
                            <span className={`text-xs px-2 py-1 rounded-full ${getStatusColor(project.status)}`}>
                              {project.status}
                            </span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
};









\\frontend/app/components/dashboard/ProjectStageInfo.tsx

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, Clock, AlertCircle, ListTodo } from "lucide-react";
import { ProjectSearchDropdown } from "./ProjectSearchDropdown";
import { useStages } from "@/hooks/use-stages";
import { type ProjectEntry } from "@/lib/schema";

interface ProjectStageInfoProps {
  project: ProjectEntry | null;
  onProjectSelect: (project: any) => void;
}

export const ProjectStageInfo: React.FC<ProjectStageInfoProps> = ({ 
  project, 
  onProjectSelect 
}) => {
  // Use the useStages hook with projectId to get both global and custom stages
  const { stages: allStages } = useStages(project?._id);
  
  // Calculate project progress based on all stages in the system
  const calculateProjectProgress = () => {
    if (!project || !project.stages || project.stages.length === 0) {
      return 0;
    }
    
    // Total stages in the system (both global and custom for this project)
    const totalStagesInSystem = allStages.length;
    
    // Stages added to this project
    const stagesInProject = project.stages.length;
    
    // Calculate progress as percentage of total stages in system
    return Math.round((stagesInProject / totalStagesInSystem) * 100);
  };
  
  const progressPercentage = calculateProjectProgress();
  
  if (!project) {
    return (
      <Card className="col-span-1">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-yellow-600" />
            Project Stage Information
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {/* Project Search Dropdown */}
            <div>
              <h3 className="text-sm font-medium mb-2">Select a Project</h3>
              <ProjectSearchDropdown 
                onProjectSelect={onProjectSelect} 
                selectedProject={null} 
              />
            </div>
            
            {/* All Stages Summary */}
            <div className="bg-blue-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <ListTodo className="h-5 w-5 text-blue-600" />
                <span className="font-medium">All Stages in System</span>
              </div>
              <div className="text-3xl font-bold text-blue-600">{allStages.length}</div>
              <div className="text-sm text-gray-600 mt-1">
                Total stages available across all projects
              </div>
            </div>
            
            <div className="flex flex-col items-center justify-center py-8 text-center text-gray-500">
              <AlertCircle className="h-12 w-12 mb-4 text-gray-400" />
              <p className="mb-2">No project selected</p>
              <p className="text-sm">Select a project from the dropdown to view stage information</p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }
  
  // Calculate stage statistics
  const totalStages = project.stages?.length || 0;
  const completedStages = project.stages?.filter(stage => stage.status === 'Completed').length || 0;
  const remainingStages = totalStages - completedStages;
  const completionPercentage = totalStages > 0 ? Math.round((completedStages / totalStages) * 100) : 0;
  
  // Count custom stages
  const customStagesCount = project.stages?.filter(stage => stage.stage.isCustom).length || 0;
  
  const getStatusColor = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  return (
    <Card className="col-span-1">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <ListTodo className="h-5 w-5 text-green-600" />
          Project Stage Information
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {/* Project Search Dropdown */}
          <div>
            <h3 className="text-sm font-medium mb-2">Select a Project</h3>
            <ProjectSearchDropdown 
              onProjectSelect={onProjectSelect} 
              selectedProject={project} 
            />
          </div>
          
          {/* All Stages Summary */}
          <div className="bg-blue-50 p-4 rounded-lg">
            <div className="flex items-center gap-2 mb-2">
              <ListTodo className="h-5 w-5 text-blue-600" />
              <span className="font-medium">All Stages in System</span>
            </div>
            <div className="text-3xl font-bold text-blue-600">{allStages.length}</div>
            <div className="text-sm text-gray-600 mt-1">
              Total stages available across all projects
            </div>
          </div>
          
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-semibold truncate">{project.project_name}</h3>
            <Badge className={getStatusColor(project.status)}>
              {project.status}
            </Badge>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-blue-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <CheckCircle className="h-5 w-5 text-blue-600" />
                <span className="font-medium">Total Stages</span>
              </div>
              <div className="text-3xl font-bold text-blue-600">{totalStages}</div>
            </div>
            
            <div className="bg-green-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <CheckCircle className="h-5 w-5 text-green-600" />
                <span className="font-medium">Completed Stages</span>
              </div>
              <div className="text-3xl font-bold text-green-600">{completedStages}</div>
              <div className="text-sm text-gray-600 mt-1">
                {completionPercentage}% of project stages
              </div>
            </div>
          </div>
          
          {/* Custom Stages Indicator */}
          {customStagesCount > 0 && (
            <div className="bg-purple-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <ListTodo className="h-5 w-5 text-purple-600" />
                <span className="font-medium">Custom Stages</span>
              </div>
              <div className="text-3xl font-bold text-purple-600">{customStagesCount}</div>
              <div className="text-sm text-gray-600 mt-1">
                Custom stages created for this project
              </div>
            </div>
          )}
          
          <div className="mt-4">
            <div className="flex justify-between text-sm mb-1">
              <span>Project Progress (vs All Stages)</span>
              <span>{progressPercentage}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-green-600 h-2.5 rounded-full" 
                style={{ width: `${progressPercentage}%` }}
              ></div>
            </div>
            <div className="text-xs text-gray-500 mt-1">
              {totalStages} of {allStages.length} total stages added to this project
            </div>
          </div>
          
          <div className="mt-4">
            <div className="flex justify-between text-sm mb-1">
              <span>Stage Completion Progress</span>
              <span>{completionPercentage}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-blue-600 h-2.5 rounded-full" 
                style={{ width: `${completionPercentage}%` }}
              ></div>
            </div>
          </div>
          
          <div className="mt-4 text-sm text-gray-600">
            <p>Remaining Stages: {remainingStages}</p>
            <p>Created: {new Date(project.created_at).toLocaleDateString()}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};












// frontend/app/component/dashboard/ProjectStatusChart.tsx
import React, { useRef, useState, useEffect } from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface ProjectStatusData {
  name: string;
  value: number;
  color: string;
}

interface ProjectStatusChartProps {
  data: ProjectStatusData[];
}

const SOFT_COLORS = [
  '#8884d8', // Soft purple
  '#82ca9d', // Soft green
  '#ffc658', // Soft yellow
  '#ff8042', // Soft orange
];

export const ProjectStatusChart: React.FC<ProjectStatusChartProps> = ({ data }) => {
  const hasData = data.some(item => item.value > 0);
  const filteredData = data.filter(item => item.value > 0);

  const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState(300);
  const [showLabels, setShowLabels] = useState(true);

  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth);
        setShowLabels(containerRef.current.offsetWidth > 200);
      }
    };
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <Card className="w-full h-full flex flex-col overflow-hidden">
      <CardHeader className="pb-2 flex-shrink-0">
        <CardTitle className="text-base sm:text-lg md:text-xl">
          Project Status Distribution
        </CardTitle>
      </CardHeader>
      <CardContent
        ref={containerRef}
        className="p-1 sm:p-2 md:p-4 flex-grow flex flex-col overflow-hidden"
      >
        <div className="h-full w-full min-h-[200px]">
          {hasData ? (
            <ResponsiveContainer width="100%" height="100%">
              <PieChart margin={{ top: 20, right: 20, left: 20, bottom: showLabels ? 60 : 20 }}>
                <Pie
                  data={filteredData}
                  cx="50%"
                  cy="50%"
                  labelLine={showLabels}
                  outerRadius={showLabels ? "65%" : "75%"}
                  fill="#8884d8"
                  dataKey="value"
                  label={showLabels ? ({ name, percent, x, y }) => {
                    const fontSize = Math.max(Math.min(containerWidth / 20, 14), 8);
                    const maxLength = containerWidth < 250 ? 6 : 10;
                    const displayName =
                      name.length > maxLength ? `${name.substring(0, maxLength)}…` : name;
                    return (
                      <text
                        x={x}
                        y={y}
                        fill="#000"
                        fontSize={fontSize}
                        textAnchor="middle"
                        dominantBaseline="central"
                      >
                        {`${displayName}: ${(percent * 100).toFixed(0)}%`}
                      </text>
                    );
                  } : false}
                  minAngle={15}
                >
                  {filteredData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={entry.color || SOFT_COLORS[index % SOFT_COLORS.length]}
                    />
                  ))}
                </Pie>
                <Tooltip formatter={(value) => [`${value} projects`, 'Count']} />
                <Legend
                  layout="horizontal"
                  verticalAlign="bottom"
                  align="center"
                  iconSize={10}
                  iconType="circle"
                  wrapperStyle={{
                    fontSize: '10px',
                    paddingTop: '5px',
                    paddingBottom: '10px'
                  }}
                />
              </PieChart>
            </ResponsiveContainer>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <p className="mb-2 text-sm md:text-base">No project data available</p>
                <p className="text-xs md:text-sm">Create projects to see status distribution</p>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};











\\frontend/app/components/dashboard/RecentProjects.tsx

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
import { useNavigate } from "react-router-dom";
import { type ProjectEntry } from "@/lib/schema";

interface RecentProjectsProps {
  projects: ProjectEntry[];
}

const getStatusBadgeClass = (status?: string) => {
  switch (status) {
    case 'Pending': return 'bg-yellow-100 text-yellow-800';
    case 'Ongoing': return 'bg-blue-100 text-blue-800';
    case 'Completed': return 'bg-green-100 text-green-800';
    case 'Archived': return 'bg-gray-100 text-gray-800';
    default: return 'bg-gray-100 text-gray-800';
  }
};

export const RecentProjects: React.FC<RecentProjectsProps> = ({ projects }) => {
  const navigate = useNavigate();
  
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };

  const handleProjectClick = (projectId: string) => {
    navigate(`/projects/${projectId}`);
  };

  return (
    <Card className="col-span-1">
      <CardHeader>
        <CardTitle>Recent Projects</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {projects.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-8 text-center text-gray-500">
              <p className="mb-2">No projects found</p>
              <p className="text-sm">Create your first project to get started</p>
            </div>
          ) : (
            projects.map((project) => (
              <div 
                key={project._id} 
                className="flex items-center justify-between p-3 rounded-lg border border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors"
                onClick={() => handleProjectClick(project._id)}
              >
                <div className="space-y-1 flex-1 min-w-0">
                  <p className="text-sm font-medium leading-none truncate">
                    {project.project_name}
                  </p>
                  <p className="text-xs text-muted-foreground">
                    Created: {formatDisplayDate(project.created_at)}
                  </p>
                </div>
                <Badge className={getStatusBadgeClass(project.status)}>
                  {project.status}
                </Badge>
              </div>
            ))
          )}
        </div>
      </CardContent>
    </Card>
  );
};











// frontend/app/component/dashboard/StageTimeTracking.tsx
import React, { useState, useEffect } from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Clock, Timer } from "lucide-react";
import { format, differenceInDays } from "date-fns";

interface StageTimeData {
  name: string;
  days: number;
}

interface StageTimeTrackingProps {
  projects: any[];
  selectedProjectId?: string;
}

export const StageTimeTracking: React.FC<StageTimeTrackingProps> = ({ 
  projects, 
  selectedProjectId 
}) => {
  const [chartData, setChartData] = useState<StageTimeData[]>([]);
  const [selectedProject, setSelectedProject] = useState<string>(selectedProjectId || 'all');
  
  // Get all projects with stages for the dropdown
  const projectOptions = [
    { value: 'all', label: 'All Projects' },
    ...projects.map(project => ({
      value: project._id,
      label: project.project_name
    }))
  ];
  
  // Process stages data to calculate completion times
  useEffect(() => {
    const allStages: any[] = [];
    
    // Collect all stages from projects
    projects.forEach(project => {
      if (project.stages && Array.isArray(project.stages)) {
        project.stages.forEach((stage: any) => {
          // Only include completed stages with both start and completion dates
          if (stage.status === 'Completed' && stage.start_date && stage.completion_date) {
            allStages.push({
              ...stage,
              project_name: project.project_name,
              project_id: project._id
            });
          }
        });
      }
    });
    
    // Filter by selected project if not 'all'
    const filteredStages = selectedProject === 'all' 
      ? allStages 
      : allStages.filter(stage => stage.project_id === selectedProject);
    
    // Calculate completion time in days for each stage
    const stageTimeData = filteredStages.map(stage => {
      const startDate = new Date(stage.start_date);
      const completionDate = new Date(stage.completion_date);
      const days = differenceInDays(completionDate, startDate);
      
      return {
        name: stage.stage.stage_name,
        days: days > 0 ? days : 1, // Ensure at least 1 day
        project: stage.project_name
      };
    });
    
    // Sort by days (ascending)
    stageTimeData.sort((a, b) => a.days - b.days);
    
    setChartData(stageTimeData);
  }, [projects, selectedProject]);
  
  const handleProjectChange = (value: string) => {
    setSelectedProject(value);
  };
  
  return (
    <Card className="col-span-1">
      <CardHeader>
        <div className="flex flex-col space-y-4">
          <CardTitle className="flex items-center gap-2">
            <Timer className="h-5 w-5 text-purple-600" />
            Stage Completion Time
          </CardTitle>
          
          <div className="w-full">
            <Select value={selectedProject} onValueChange={handleProjectChange}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select a project" />
              </SelectTrigger>
              <SelectContent>
                {projectOptions.map(option => (
                  <SelectItem key={option.value} value={option.value} className="max-w-xs">
                    <div className="break-words">{option.label}</div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent className="h-80">
        {chartData.length > 0 ? (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{
                top: 5,
                right: 30,
                left: 20,
                bottom: 5,
              }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis label={{ value: 'Days', angle: -90, position: 'insideLeft' }} />
              <Tooltip 
                formatter={(value) => [`${value} days`, 'Completion Time']}
                labelFormatter={(label) => `Stage: ${label}`}
              />
              <Legend />
              <Bar 
                dataKey="days" 
                fill="#8884d8" 
                name="Days to Complete"
              />
            </BarChart>
          </ResponsiveContainer>
        ) : (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <Timer className="h-12 w-12 mb-4 text-gray-400" />
              <p className="mb-2">No stage completion data available</p>
              <p className="text-sm">Complete some project stages to see completion times</p>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};









// frontend/app/component/dashboard/StatsCard.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useNavigate } from "react-router-dom";

interface StatsCardProps {
  title: string;
  value: number | string;
  description?: string;
  icon: any;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  color?: string;
  filterType?: 'all' | 'ongoing' | 'completed' | 'pending';
  onClick?: () => void;
}

export const StatsCard: React.FC<StatsCardProps> = ({
  title,
  value,
  description,
  icon: Icon,
  trend,
  className,
  color = "bg-blue-50",
  filterType,
  onClick
}) => {
  const navigate = useNavigate();
  
  const handleClick = () => {
    if (onClick) {
      onClick();
      return;
    }
    
    if (filterType) {
      // Navigate to projects page with filter
      // For "all", use "all" directly, for others use proper case (first letter capitalized)
      const filterValue = filterType === 'all' ? 'all' : filterType.charAt(0).toUpperCase() + filterType.slice(1);
      console.log(`Navigating to /projects?filter=${filterValue}`); // Debug log
      navigate(`/projects?filter=${filterValue}`);
    }
  };

  const getCardColor = () => {
    switch (filterType) {
      case 'ongoing': return 'bg-blue-50 hover:bg-blue-100 border-blue-200';
      case 'completed': return 'bg-green-50 hover:bg-green-100 border-green-200';
      case 'pending': return 'bg-yellow-50 hover:bg-yellow-100 border-yellow-200';
      default: return `${color} hover:bg-gray-100`;
    }
  };

  const getIconColor = () => {
    switch (filterType) {
      case 'ongoing': return 'text-blue-600';
      case 'completed': return 'text-green-600';
      case 'pending': return 'text-yellow-600';
      default: return 'text-gray-600';
    }
  };

  const getBadgeColor = () => {
    switch (filterType) {
      case 'ongoing': return 'bg-blue-100 text-blue-800';
      case 'completed': return 'bg-green-100 text-green-800';
      case 'pending': return 'bg-yellow-100 text-yellow-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <Card 
      className={`cursor-pointer transition-all duration-200 ${getCardColor()} ${className}`}
      onClick={handleClick}
    >
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium flex items-center gap-2">
          {title}
          {filterType && (
            <Badge className={getBadgeColor()}>
              {filterType}
            </Badge>
          )}
        </CardTitle>
        <Icon className={`h-5 w-5 ${getIconColor()}`} />
      </CardHeader>
      <CardContent>
        <div className="text-3xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground mt-1">
            {description}
          </p>
        )}
        {trend && (
          <div className={`flex items-center text-xs mt-1 ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
            <span>{trend.isPositive ? '↑' : '↓'} {Math.abs(trend.value)}%</span>
            <span className="ml-1">from last month</span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};




















// frontend/app/component/email-management.tsx
"use client";
import React, { useState, useEffect } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader } from "@/components/loader";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert, Trash2, Pencil, Plus, Share } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Checkbox } from "@/components/ui/checkbox";
import { Badge } from "@/components/ui/badge";
import { useEmails } from "@/hooks/use-emails";
import { useAuth } from "@/provider/auth-context";
import { emailSchema, type EmailEntry } from "@/lib/schema";
import { z } from "zod";
import { SearchBar } from "@/components/ui/search-bar";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { postData, fetchData } from "@/lib/fetch-util";
import { toast } from "sonner";
import type { ProjectEntry } from "@/lib/schema";

const EmailManagement = () => {
  const { user } = useAuth();
  const { emails, isLoading, error, addEmail, updateEmail, deleteEmail } = useEmails();
  const [showModal, setShowModal] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [emailToDelete, setEmailToDelete] = useState<string | null>(null);
  const [currentEmail, setCurrentEmail] = useState<EmailEntry | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [showShareDialog, setShowShareDialog] = useState(false);
  const [selectedProjectId, setSelectedProjectId] = useState<string>('');
  const [selectedEmails, setSelectedEmails] = useState<string[]>([]);
  const [projects, setProjects] = useState<ProjectEntry[]>([]);
  const [projectsLoading, setProjectsLoading] = useState<boolean>(false);
  
  const queryClient = useQueryClient();
  
  // Determine if user can edit emails
  const canEditEmails = user?.role === "manager";
  
  const form = useForm<z.infer<typeof emailSchema>>({
    resolver: zodResolver(emailSchema),
    defaultValues: {
      name: "",
      email: "",
    },
  });
  
  // Mutation for sharing project details
// In the shareProjectMutation in the EmailManagement component

const shareProjectMutation = useMutation({
  mutationFn: (data: { projectId: string; emailIds: string[] }) => 
    postData('/emails/share-project', data),
  onSuccess: () => {
    toast.success("Project details shared successfully");
    setShowShareDialog(false);
    setSelectedEmails([]);
    setSelectedProjectId('');
  },
  onError: (error: any) => {
    console.error("Share project error:", error);
    const errorMessage = error.response?.data?.message || error.message || "Failed to share project details";
    toast.error(errorMessage);
  },
});
  
  // Filter emails based on search term
  const filteredEmails = React.useMemo(() => {
    if (!searchTerm) return emails;
    
    const term = searchTerm.toLowerCase();
    return emails.filter(email => 
      email.name.toLowerCase().includes(term) ||
      email.email.toLowerCase().includes(term)
    );
  }, [emails, searchTerm]);
  
  // Fetch projects for sharing dialog
  const fetchProjects = async () => {
    if (!canEditEmails) return;
    
    setProjectsLoading(true);
    try {
      const projectsData = await fetchData<ProjectEntry[]>('/projects/all-projects');
      setProjects(projectsData);
    } catch (error) {
      console.error('Error fetching projects:', error);
      toast.error("Failed to fetch projects");
    } finally {
      setProjectsLoading(false);
    }
  };
  
  // Load projects when the share dialog is opened
  React.useEffect(() => {
    if (showShareDialog && canEditEmails) {
      fetchProjects();
    }
  }, [showShareDialog, canEditEmails]);
  
  const handleAddClick = () => {
    // Only managers can add emails
    if (!canEditEmails) {
      alert("Only managers can add emails");
      return;
    }
    
    setCurrentEmail(null);
    form.reset({ name: "", email: "" });
    setShowModal(true);
  };
  
  const handleEditClick = (email: EmailEntry) => {
    // Only managers can edit emails
    if (!canEditEmails) {
      alert("Only managers can edit emails");
      return;
    }
    
    setCurrentEmail(email);
    form.reset({ name: email.name, email: email.email });
    setShowModal(true);
  };
  
  const handleDeleteClick = (_id: string) => {
    // Only managers can delete emails
    if (!canEditEmails) {
      alert("Only managers can delete emails");
      return;
    }
    
    setEmailToDelete(_id);
    setShowDeleteDialog(true);
  };
  
  const handleConfirmDelete = async () => {
    if (emailToDelete) {
      await deleteEmail(emailToDelete);
    }
    setShowDeleteDialog(false);
    setEmailToDelete(null);
  };
  
  const handleSubmit = async (values: z.infer<typeof emailSchema>) => {
    if (currentEmail) {
      // Editing an existing email
      await updateEmail(currentEmail._id, values);
    } else {
      // Adding a new email
      // Check for duplicate emails on the frontend
      const isDuplicate = emails.some(entry => entry.email === values.email);
      if (isDuplicate) {
        // Use setError to display the error message on the email field
        form.setError("email", {
          type: "manual",
          message: "This email is already added.",
        });
        return; // Stop the function here
      }
      await addEmail(values);
    }
    setShowModal(false);
  };
  
  const handleShareClick = () => {
    if (!canEditEmails) {
      alert("Only managers can share project details");
      return;
    }
    
    if (emails.length === 0) {
      alert("Please add email addresses first");
      return;
    }
    
    setShowShareDialog(true);
  };
  
  const handleEmailSelection = (emailId: string, checked: boolean) => {
    if (checked) {
      setSelectedEmails([...selectedEmails, emailId]);
    } else {
      setSelectedEmails(selectedEmails.filter(id => id !== emailId));
    }
  };
  
  const handleSelectAllEmails = (checked: boolean) => {
    if (checked) {
      setSelectedEmails(emails.map(email => email._id));
    } else {
      setSelectedEmails([]);
    }
  };
  
  const handleShareProject = () => {
    if (!selectedProjectId) {
      alert("Please select a project");
      return;
    }
    
    if (selectedEmails.length === 0) {
      alert("Please select at least one email address");
      return;
    }
    
    shareProjectMutation.mutate({
      projectId: selectedProjectId,
      emailIds: selectedEmails
    });
  };
  
  return (
    <div className="container mx-auto p-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-2xl font-bold">
          {canEditEmails ? "Email Management" : "Emails"}
        </h3>
        <div className="flex gap-2">
          {canEditEmails && (
            <>
              <Button onClick={handleShareClick} className="flex items-center gap-2">
                <Share className="h-4 w-4" />
                Share Project
              </Button>
              <Button onClick={handleAddClick} className="flex items-center gap-2">
                <Plus className="h-4 w-4" />
                Add Email
              </Button>
            </>
          )}
        </div>
      </div>
      
      {/* Search Input using the reusable SearchBar component */}
      <div className="mb-4 p-3 bg-gray-50 rounded-lg">
        <SearchBar 
          placeholder="Search emails..." 
          value={searchTerm} 
          onChange={setSearchTerm} 
        />
      </div>
      
      {error && (
        <Alert variant="destructive" className="mb-4">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {isLoading ? (
        <Loader />
      ) : (
        <div className="rounded-md border">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-[50px]">#</TableHead>
                <TableHead>Name</TableHead>
                <TableHead>Email</TableHead>
                {canEditEmails && <TableHead className="text-right">Actions</TableHead>}
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredEmails.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={canEditEmails ? 4 : 3} className="text-center">
                    No emails found.
                  </TableCell>
                </TableRow>
              ) : (
                filteredEmails.map((entry, index) => (
                  <TableRow key={entry._id}>
                    <TableCell>{index + 1}</TableCell>
                    <TableCell>{entry.name}</TableCell>
                    <TableCell>{entry.email}</TableCell>
                    {canEditEmails && (
                      <TableCell className="text-right">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="text-yellow-500 hover:text-yellow-700"
                          onClick={() => handleEditClick(entry)}
                        >
                          <Pencil className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="text-red-500 hover:text-red-700 ml-2"
                          onClick={() => handleDeleteClick(entry._id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </TableCell>
                    )}
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      )}
      
      {/* Modal for Adding & Editing Emails - Only for Managers */}
      {canEditEmails && (
        <>
          <Dialog open={showModal} onOpenChange={setShowModal}>
            <DialogContent className="sm:max-w-[425px]">
              <DialogHeader>
                <DialogTitle>
                  {currentEmail ? "Edit Email" : "Add Email"}
                </DialogTitle>
                <DialogDescription>
                  {currentEmail 
                    ? "Update the email details below."
                    : "Fill in the details to add a new email."
                  }
                </DialogDescription>
              </DialogHeader>
              <Form {...form}>
                <form onSubmit={form.handleSubmit(handleSubmit)}>
                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem className="mb-4">
                        <FormLabel>Name</FormLabel>
                        <FormControl>
                          <Input placeholder="Enter Name" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={form.control}
                    name="email"
                    render={({ field }) => (
                      <FormItem className="mb-4">
                        <FormLabel>Email</FormLabel>
                        <FormControl>
                          <Input type="email" placeholder="Enter Email" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <DialogFooter className="mt-4">
                    <Button type="submit">
                      {currentEmail ? "Update Email" : "Add Email"}
                    </Button>
                  </DialogFooter>
                </form>
              </Form>
            </DialogContent>
          </Dialog>
          
          {/* Custom Confirmation Dialog for Deleting */}
          <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                <AlertDialogDescription>
                  This action cannot be undone. This will permanently delete the email entry.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
          
          {/* Share Project Dialog */}
          <Dialog open={showShareDialog} onOpenChange={setShowShareDialog}>
            <DialogContent className="sm:max-w-[500px]">
              <DialogHeader>
                <DialogTitle>Share Project Details</DialogTitle>
                <DialogDescription>
                  Select a project and email addresses to share the project details as a PDF attachment.
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <label className="text-sm font-medium">Select Project</label>
                  {projectsLoading ? (
                    <div className="flex items-center justify-center h-10 mt-1">
                      <Loader className="h-4 w-4 animate-spin" />
                    </div>
                  ) : (
                    <select 
                      className="w-full mt-1 p-2 border rounded-md"
                      value={selectedProjectId}
                      onChange={(e) => setSelectedProjectId(e.target.value)}
                    >
                      <option value="">Select a project</option>
                      {projects.map(project => (
                        <option key={project._id} value={project._id}>
                          {project.project_name}
                        </option>
                      ))}
                    </select>
                  )}
                </div>
                
                <div>
                  <div className="flex items-center space-x-2 mb-2">
                    <Checkbox
                      id="selectAll"
                      checked={selectedEmails.length === emails.length && emails.length > 0}
                      onCheckedChange={handleSelectAllEmails}
                    />
                    <label htmlFor="selectAll" className="text-sm font-medium">
                      Select All Emails
                    </label>
                  </div>
                  
                  <div className="max-h-60 overflow-y-auto border rounded-md p-2">
                    {emails.length === 0 ? (
                      <div className="text-center py-4 text-gray-500">
                        No email addresses available
                      </div>
                    ) : (
                      emails.map(email => (
                        <div key={email._id} className="flex items-center space-x-2 py-1">
                          <Checkbox
                            id={`email-${email._id}`}
                            checked={selectedEmails.includes(email._id)}
                            onCheckedChange={(checked) => handleEmailSelection(email._id, checked as boolean)}
                          />
                          <label htmlFor={`email-${email._id}`} className="text-sm">
                            {email.name} ({email.email})
                          </label>
                        </div>
                      ))
                    )}
                  </div>
                </div>
                
                {selectedEmails.length > 0 && (
                  <div className="flex flex-wrap gap-1">
                    {selectedEmails.map(emailId => {
                      const email = emails.find(e => e._id === emailId);
                      return (
                        <Badge key={emailId} variant="secondary" className="text-xs">
                          {email?.name}
                        </Badge>
                      );
                    })}
                  </div>
                )}
              </div>
              <DialogFooter>
                <Button variant="outline" onClick={() => setShowShareDialog(false)}>
                  Cancel
                </Button>
                <Button 
                  onClick={handleShareProject}
                  disabled={shareProjectMutation.isPending || !selectedProjectId || selectedEmails.length === 0}
                >
                  {shareProjectMutation.isPending ? "Sharing..." : "Share Project"}
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </>
      )}
    </div>
  );
};

export default EmailManagement;

















// frontend/app/component/layout/header.tsx
import { useAuth } from "@/provider/auth-context";
import { Button } from "../ui/button";
import { Bell } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuItem,
} from "../ui/dropdown-menu";
import { Avatar, AvatarImage, AvatarFallback } from "../ui/avatar";
import { Link, useNavigate } from "react-router";
import { BarChart3 } from "lucide-react";
import { memo } from "react";

interface HeaderProps {
  onProjectSelect?: (project: any) => void;
  selectedProject?: any;
}

// Memoize the Header component to prevent unnecessary re-renders
const HeaderComponent = memo(({ onProjectSelect, selectedProject }: HeaderProps) => {
  const navigate = useNavigate();
  const { user, logout } = useAuth();
  
  return (
    <div className="bg-background sticky top-0 z-40 border-b">
      <div className="flex h-14 items-center justify-between px-4 sm:px-6 lg:px-8 py-4">
        <div className="flex items-center">
          {/* <BarChart3 className="h-6 w-6 text-blue-600 mr-2" /> */}
          <h1 className="text-xl font-bold"></h1>
        </div>
        
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon">
            <Bell />
          </Button>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button className="rounded-full border p-1 w-8 h-8">
                <Avatar className="w-8 h-8">
                  <AvatarImage src={user?.profilePicture} alt={user?.name} />
                  <AvatarFallback className="bg-primary text-primary-foreground">
                    {user?.name?.charAt(0).toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Link to="/user/profile">Profile</Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={logout}>Log Out</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </div>
  );
});

HeaderComponent.displayName = 'Header';

// Export the component with the name 'Header'
export { HeaderComponent as Header };
















\\// frontend/app/component/layout/sidebar-component.tsx

import { cn } from "@/lib/utils";
import { useAuth } from "@/provider/auth-context";
import {
  CheckCircle2,
  ChevronsLeft,
  ChevronsRight,
  LayoutDashboard,
  ListCheck,
  LogOut,
  Settings,
  Users,
  Mail,
  Plus,
  Wrench,
  BarChart3
} from "lucide-react";
import { useState } from "react";
import { Link, useLocation } from "react-router-dom";
import { Button } from "../ui/button";
import { ScrollArea } from "../ui/scroll-area";
import { SidebarNav } from "./sidebar-nav";

export const SidebarComponent = () => {
  const { user, logout } = useAuth();
  const [isCollapsed, setIsCollapsed] = useState(false);
  const location = useLocation();
  
  // Define navigation items based on user role
  const getNavItems = () => {
    const baseItems = [
      {
        title: "Dashboard",
        href: "/dashboard",
        icon: LayoutDashboard,
      },
    ];
    
    if (user?.role === "manager") {
      // Managers can see and access everything
      baseItems.push(
        {
          title: "Create Project",
          href: "/projects",
          icon: Plus,
        },
        {
          title: "Create Stages",
          href: "/stages",
          icon: Plus,
        },
        {
          title: "Emails",
          href: "/emails",
          icon: Mail,
        }
      );
    } else {
      // Regular users can only view projects
      baseItems.push(
        {
          title: "Projects",
          href: "/projects",
          icon: Plus,
        }
      );
    }
    
    // Both roles can access these
    baseItems.push(
      {
        title: "User Profile",
        href: "/user/profile",
        icon: Users,
      },
      {
        title: "Settings",
        href: "/settings",
        icon: Settings,
      }
    );
    
    return baseItems;
  };
  
  const navItems = getNavItems();
  
  return (
    <div
      className={cn(
        "flex flex-col border-r bg-sidebar transition-all duration-300",
        isCollapsed ? "w-16 md:w-[80px]" : "w-16 md:w-[240px]"
      )}
    >
      <div className="flex h-14 items-center border-b px-4 mb-4">
        <Link to="/dashboard" className="flex items-center">
          {!isCollapsed && (
            <div className="flex items-center gap-2">
              <BarChart3 className="size-6 text-blue-600" />
              <span className="font-semibold text-lg hidden md:block">
                TaskHub
              </span>
            </div>
          )}
          {isCollapsed && <BarChart3 className="size-6 text-blue-600" />}
        </Link>
        <Button
          variant={"ghost"}
          size="icon"
          className="ml-auto hidden md:block"
          onClick={() => setIsCollapsed(!isCollapsed)}
        >
          {isCollapsed ? (
            <ChevronsRight className="size-4" />
          ) : (
            <ChevronsLeft className="size-4" />
          )}
        </Button>
      </div>
      <ScrollArea className="flex-1 px-3 py-2">
        <SidebarNav
          items={navItems}
          isCollapsed={isCollapsed}
          className={cn(isCollapsed && "items-center space-y-2")}
        />
      </ScrollArea>
      <div className="mt-auto px-3 py-2">
        <Button
          variant={"ghost"}
          size={isCollapsed ? "icon" : "default"}
          className="w-full"
          onClick={logout}
        >
          <LogOut className={cn("size-4 mr-2", isCollapsed && "mr-0")} />
          {!isCollapsed && <span className="hidden md:block">Logout</span>}
        </Button>
      </div>
    </div>
  );
};















// frontend/app/component/layout/sidebar-nav.tsx


import { cn } from "@/lib/utils";
import type { LucideIcon } from "lucide-react";
import { Button } from "../ui/button";
import { useLocation, useNavigate } from "react-router";

interface SidebarNavProps extends React.HtmlHTMLAttributes<HTMLElement> {
  items: {
    title: string;
    href: string;
    icon: LucideIcon;
  }[];
  isCollapsed: boolean;
  className?: string;
}

export const SidebarNav = ({
  items,
  isCollapsed,
  className,
  ...props
}: SidebarNavProps) => {
  const location = useLocation();
  const navigate = useNavigate();

  return (
    <nav className={cn("flex flex-col gap-y-2", className)} {...props}>
      {items.map((el) => {
        const Icon = el.icon;
        const isActive = location.pathname === el.href;
        const handleClick = () => {
          navigate(el.href);
        };

        return (
          <Button
            key={el.href}
            variant={isActive ? "outline" : "ghost"}
            className={cn(
              "justify-start",
              isActive && "bg-blue-800/20 text-blue-600 font-medium"
            )}
            onClick={handleClick}
          >
            <Icon className="mr-2 size-4" />
            {isCollapsed ? (
              <span className="sr-only">{el.title}</span>
            ) : (
              el.title
            )}
          </Button>
        );
      })}
    </nav>
  );
};










// frontend/app/component/projects/hooks/useProjectFilters.tsx
import { useMemo } from 'react';
import { type ProjectEntry } from '@/lib/schema';

interface UseProjectFiltersProps {
  projects: ProjectEntry[];
  sortBy: 'newest' | 'oldest';
  statusFilter: string;
  searchTerm: string;
  dateRange: {
    startDate: string | undefined;
    endDate: string | undefined;
  };
}

export const useProjectFilters = ({
  projects,
  sortBy,
  statusFilter,
  searchTerm,
  dateRange
}: UseProjectFiltersProps) => {
  const filteredAndSortedProjects = useMemo(() => {
    console.log("useProjectFilters called with:", {
      projectsCount: projects.length,
      statusFilter,
      searchTerm,
      dateRange
    });
    
    let result = [...projects];
    
    // Apply search filter
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      result = result.filter(project =>
        project.project_name.toLowerCase().includes(term) ||
        (project.description && project.description.toLowerCase().includes(term)) ||
        (project.status && project.status.toLowerCase().includes(term))
      );
    }
    
    // Apply status filter (case insensitive)
    if (statusFilter !== 'all') {
      console.log(`Filtering by status: ${statusFilter}`);
      console.log(`Projects before status filter: ${result.length}`);
      result = result.filter(project => {
        // Compare in lowercase for case insensitivity
        return project.status && project.status.toLowerCase() === statusFilter.toLowerCase();
      });
      console.log(`Projects after status filter: ${result.length}`);
    }
    
    // Apply date range filter
    if (dateRange.startDate && dateRange.endDate) {
      const startDate = new Date(dateRange.startDate);
      const endDate = new Date(dateRange.endDate);
      result = result.filter(project => {
        const projectDate = new Date(project.created_at);
        return projectDate >= startDate && projectDate <= endDate;
      });
    }
    
    // Apply sorting
    result.sort((a, b) => {
      const dateA = new Date(a.created_at).getTime();
      const dateB = new Date(b.created_at).getTime();
      if (sortBy === 'newest') {
        return dateB - dateA; // Most recent first
      } else {
        return dateA - dateB; // Oldest first
      }
    });
    
    console.log("Final filtered projects:", result);
    return result;
  }, [projects, statusFilter, sortBy, searchTerm, dateRange]);
  
  return {
    filteredAndSortedProjects,
    hasProjects: projects.length > 0,
    hasFilteredProjects: filteredAndSortedProjects.length > 0
  };
};










// frontend/app/components/projects/ConnectionForm.tsx
import React, { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";
import { type ProjectStageEntry, type StageConnectionEntry } from "@/lib/schema";
import { ArrowRight } from "lucide-react";

interface ConnectionFormProps {
  stages: ProjectStageEntry[];
  connections: StageConnectionEntry[];
  onSubmit: (fromStageId: string, toStageId: string) => void;
  onCancel: () => void;
}

export const ConnectionForm: React.FC<ConnectionFormProps> = ({
  stages,
  connections,
  onSubmit,
  onCancel
}) => {
  const [fromStageId, setFromStageId] = useState<string>('');
  const [toStageId, setToStageId] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = () => {
    if (!fromStageId || !toStageId) {
      setError("Please select both source and destination stages");
      return;
    }
    
    if (fromStageId === toStageId) {
      setError("Source and destination stages cannot be the same");
      return;
    }
    
    // Check if connection already exists
    const connectionExists = connections.some(conn => 
      conn.from_stage._id === fromStageId && conn.to_stage._id === toStageId
    );
    
    if (connectionExists) {
      setError("This connection already exists");
      return;
    }
    
    onSubmit(fromStageId, toStageId);
  };
  
  return (
    <Dialog open={true} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Connect Stages</DialogTitle>
          <DialogDescription>
            Create a connection between two stages in your project.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          <div className="flex items-center space-x-4">
            <div className="flex-1 space-y-2">
              <label className="text-sm font-medium">From Stage</label>
              <Select value={fromStageId} onValueChange={setFromStageId}>
                <SelectTrigger className="h-auto py-2">
                  <SelectValue placeholder="Select source stage" />
                </SelectTrigger>
                <SelectContent>
                  {stages.map(stage => (
                    <SelectItem key={`from-${stage._id}`} value={stage._id} className="whitespace-normal">
                      <div className="max-w-xs">
                        <div className="whitespace-normal break-words">
                          {stage.stage.stage_name}
                        </div>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            <div className="flex items-center justify-center mt-6">
              <ArrowRight className="h-6 w-6 text-muted-foreground" />
            </div>
            
            <div className="flex-1 space-y-2">
              <label className="text-sm font-medium">To Stage</label>
              <Select value={toStageId} onValueChange={setToStageId}>
                <SelectTrigger className="h-auto py-2">
                  <SelectValue placeholder="Select destination stage" />
                </SelectTrigger>
                <SelectContent>
                  {stages.map(stage => (
                    <SelectItem key={`to-${stage._id}`} value={stage._id} className="whitespace-normal">
                      <div className="max-w-xs">
                        <div className="whitespace-normal break-words">
                          {stage.stage.stage_name}
                        </div>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
        
        <DialogFooter className="mt-6">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button onClick={handleSubmit}>
            Create Connection
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};








\\// frontend/app/components/projects/ConnectionLine.tsx
import React from "react";
import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { type StageConnectionEntry } from "@/lib/schema";

interface ConnectionLineProps {
  connection: StageConnectionEntry;
  onRemove: (connectionId: string) => void;
  position: {
    x: number;
    y: number;
  };
}

export const ConnectionLine: React.FC<ConnectionLineProps> = ({ 
  connection, 
  onRemove,
  position
}) => {
  return (
    <div 
      className="absolute pointer-events-auto z-30" 
      style={{
        left: position.x,
        top: position.y,
        transform: 'translate(-50%, -50%)'
      }}
    >
      <Button
        variant="outline"
        size="sm"
        className="bg-white shadow-md hover:bg-red-50 hover:text-red-600 transition-colors"
        onClick={(e) => {
          e.stopPropagation();
          onRemove(connection._id);
        }}
      >
        <X className="h-3 w-3" />
      </Button>
    </div>
  );
};















\\/frontend/app/components/projects/CustomStageForm.tsx
import React, { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

const customStageSchema = z.object({
  stage_name: z.string().min(1, { message: "Stage name is required" }),
  description: z.string().optional(),
});

type CustomStageValues = z.infer<typeof customStageSchema>;

interface CustomStageFormProps {
  projectId: string;
  onSuccess: () => void;
  onCancel: () => void;
}

export const CustomStageForm: React.FC<CustomStageFormProps> = ({
  projectId,
  onSuccess,
  onCancel
}) => {
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  const [isCreating, setIsCreating] = useState(false);
  
  const form = useForm<CustomStageValues>({
    resolver: zodResolver(customStageSchema),
    defaultValues: {
      stage_name: "",
      description: "",
    },
  });

  const handleSubmit = async (values: CustomStageValues) => {
    if (!projectId) return;
    
    setIsCreating(true);
    try {
      const response = await fetch(`${API_BASE_URL}/stages/add-stage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          ...values,
          isCustom: true,
          projectId: projectId,
        }),
      });

      if (!response.ok) {
        throw new Error("Failed to create custom stage");
      }

      form.reset();
      onSuccess();
    } catch (error) {
      console.error("Error creating custom stage:", error);
      setAlertMessage("Failed to create custom stage");
      setShowAlert(true);
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <Dialog open={true} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Create Custom Stage</DialogTitle>
          <DialogDescription>
            Create a custom stage specific to this project.
          </DialogDescription>
        </DialogHeader>
        
        {showAlert && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{alertMessage}</AlertDescription>
          </Alert>
        )}
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="stage_name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Stage Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter stage name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter stage description" 
                      className="min-h-[100px]"
                      {...field} 
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <DialogFooter>
              <Button type="button" variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button type="submit" disabled={isCreating}>
                {isCreating ? "Creating..." : "Create Custom Stage"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};













\\/frontend/app/components/projects/EditCustomStage.tsx

import React, { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle, Loader2 } from "lucide-react";
import { type StageEntry } from "@/lib/schema";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

const customStageSchema = z.object({
  stage_name: z.string().min(1, { message: "Stage name is required" }),
  description: z.string().optional(),
});

type CustomStageValues = z.infer<typeof customStageSchema>;

interface EditCustomStageProps {
  stage: StageEntry;
  projectId: string;
  isOpen: boolean;
  onOpenChange: (open: boolean) => void; // Changed from onClose to onOpenChange
  onSuccess: () => void;
}

export const EditCustomStage: React.FC<EditCustomStageProps> = ({
  stage,
  projectId,
  isOpen,
  onOpenChange,
  onSuccess
}) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const form = useForm<CustomStageValues>({
    resolver: zodResolver(customStageSchema),
    defaultValues: {
      stage_name: stage.stage_name,
      description: stage.description || "",
    },
  });

  const handleSubmit = async (values: CustomStageValues) => {
    setIsSubmitting(true);
    setError(null);
    
    try {
      const response = await fetch(`${API_BASE_URL}/stages/update-stage/${stage._id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(values),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to update custom stage");
      }

      onSuccess();
      onOpenChange(false); // Close the dialog after successful update
    } catch (err) {
      console.error("Error updating custom stage:", err);
      setError(err instanceof Error ? err.message : "Failed to update custom stage");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleCancel = () => {
    onOpenChange(false); // Close the dialog when cancel is clicked
  };

  return (
    <Dialog open={isOpen} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <span className="w-3 h-3 bg-purple-500 rounded-full"></span>
            Edit Custom Stage
          </DialogTitle>
          <DialogDescription>
            Update the name and description for this custom stage. Changes will be reflected across all projects using this stage.
          </DialogDescription>
        </DialogHeader>
        
        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="stage_name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Stage Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter stage name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Enter stage description" 
                      className="min-h-[100px]"
                      {...field} 
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <div className="bg-gray-50 p-3 rounded-lg">
              <p className="text-sm text-gray-600">
                <span className="font-medium">Project:</span> {projectId}
              </p>
              <p className="text-sm text-gray-600">
                <span className="font-medium">Stage Type:</span> Custom (Project Specific)
              </p>
            </div>
            
            <DialogFooter className="mt-4">
              <Button type="button" variant="outline" onClick={handleCancel}>
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Updating...
                  </>
                ) : (
                  "Update Stage"
                )}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};











\\/frontend/app/components/projects/EmailShareDialog.tsx

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Checkbox } from "@/components/ui/checkbox";
import { Badge } from "@/components/ui/badge";
import { Search, Check } from "lucide-react";
import { useEmails } from "@/hooks/use-emails";
import { Loader2 } from "lucide-react";
import { type EmailEntry } from "@/lib/schema";

interface EmailShareDialogProps {
  isOpen: boolean;
  onClose: () => void;
  project: {
    _id: string;
    project_name: string;
  };
  onSubmit: (emailIds: string[]) => void;
  isLoading: boolean;
}

export const EmailShareDialog: React.FC<EmailShareDialogProps> = ({
  isOpen,
  onClose,
  project,
  onSubmit,
  isLoading
}) => {
  const { emails } = useEmails();
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedEmails, setSelectedEmails] = useState<string[]>([]);
  const [filteredEmails, setFilteredEmails] = useState<EmailEntry[]>([]);

  // Filter emails based on search term
  useEffect(() => {
    if (!searchTerm) {
      setFilteredEmails(emails);
    } else {
      const term = searchTerm.toLowerCase();
      setFilteredEmails(
        emails.filter(
          (email) =>
            email.name.toLowerCase().includes(term) ||
            email.email.toLowerCase().includes(term)
        )
      );
    }
  }, [emails, searchTerm]);

  const handleEmailSelect = (emailId: string, checked: boolean) => {
    if (checked) {
      setSelectedEmails([...selectedEmails, emailId]);
    } else {
      setSelectedEmails(selectedEmails.filter((id) => id !== emailId));
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedEmails(filteredEmails.map((email) => email._id));
    } else {
      setSelectedEmails([]);
    }
  };

  const handleSubmit = () => {
    if (selectedEmails.length === 0) {
      alert("Please select at least one email address");
      return;
    }
    onSubmit(selectedEmails);
  };

  const isAllSelected = 
    filteredEmails.length > 0 && 
    selectedEmails.length === filteredEmails.length &&
    filteredEmails.every(email => selectedEmails.includes(email._id));

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Share Project Details</DialogTitle>
          <DialogDescription>
            Share the project details for "{project.project_name}" as PDF with selected email recipients.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          {/* Search Input */}
          <div className="relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
            <Input
              placeholder="Search emails..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-10"
            />
          </div>
          
          {/* Select All Checkbox */}
          <div className="flex items-center space-x-2">
            <Checkbox
              id="select-all"
              checked={isAllSelected}
              onCheckedChange={handleSelectAll}
            />
            <Label htmlFor="select-all" className="text-sm font-medium">
              Select All ({filteredEmails.length})
            </Label>
          </div>
          
          {/* Email List */}
          <div className="max-h-60 overflow-y-auto border rounded-md p-2">
            {filteredEmails.length === 0 ? (
              <div className="text-center py-4 text-gray-500">
                {emails.length === 0 
                  ? "No emails available. Add emails to share projects." 
                  : "No emails match your search."
                }
              </div>
            ) : (
              <div className="space-y-2">
                {filteredEmails.map((email) => (
                  <div
                    key={email._id}
                    className="flex items-center space-x-3 p-2 hover:bg-gray-50 rounded-md"
                  >
                    <Checkbox
                      id={`email-${email._id}`}
                      checked={selectedEmails.includes(email._id)}
                      onCheckedChange={(checked) => handleEmailSelect(email._id, checked as boolean)}
                    />
                    <div className="flex-1 min-w-0">
                      <Label
                        htmlFor={`email-${email._id}`}
                        className="text-sm font-medium cursor-pointer truncate"
                      >
                        {email.name}
                      </Label>
                      <p className="text-xs text-gray-500 truncate">
                        {email.email}
                      </p>
                    </div>
                    {selectedEmails.includes(email._id) && (
                      <Check className="h-4 w-4 text-green-500" />
                    )}
                  </div>
                ))}
              </div>
            )}
          </div>
          
          {/* Selected Count */}
          {selectedEmails.length > 0 && (
            <div className="flex items-center justify-between">
              <span className="text-sm text-gray-600">
                {selectedEmails.length} recipient{selectedEmails.length !== 1 ? 's' : ''} selected
              </span>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setSelectedEmails([])}
                className="text-xs"
              >
                Clear Selection
              </Button>
            </div>
          )}
        </div>
        
        <DialogFooter>
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button 
            onClick={handleSubmit} 
            disabled={isLoading || selectedEmails.length === 0}
          >
            {isLoading ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Sharing...
              </>
            ) : (
              `Share (${selectedEmails.length})`
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};








\\/frontend/app/components/projects/project-card.tsx
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Pencil, Trash2, Calendar, Eye } from "lucide-react";
import { format } from "date-fns";
import { type ProjectEntry } from "@/lib/schema";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ProjectCardProps {
  project: ProjectEntry;
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
  canEdit: boolean;
}

export const ProjectCard: React.FC<ProjectCardProps> = ({ 
  project, 
  onEdit, 
  onDelete,
  onProjectClick,
  canEdit
}) => {
  // Get status badge color based on status value
  const getStatusBadgeClass = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  // Format date for display
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  return (
    <Card 
      className="h-full flex flex-col cursor-pointer hover:shadow-md transition-shadow"
      onClick={() => onProjectClick(project._id)}
    >
      <CardHeader className="pb-3">
        <div className="flex justify-between items-start">
          <Tooltip>
            <TooltipTrigger asChild>
              <CardTitle className="text-lg font-semibold line-clamp-2">
                {project.project_name}
              </CardTitle>
            </TooltipTrigger>
            <TooltipContent>
              <p>{project.project_name}</p>
            </TooltipContent>
          </Tooltip>
          <div className="flex gap-1">
            <Button 
              variant="ghost" 
              size="sm" 
              className="text-blue-500 hover:text-blue-700 h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                onProjectClick(project._id);
              }}
            >
              <Eye className="h-4 w-4" />
            </Button>
            {canEdit && (
              <>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  className="text-yellow-500 hover:text-yellow-700 h-8 w-8 p-0"
                  onClick={(e) => {
                    e.stopPropagation();
                    onEdit(project);
                  }}
                >
                  <Pencil className="h-4 w-4" />
                </Button>
                <Button 
                  variant="ghost" 
                  size="sm" 
                  className="text-red-500 hover:text-red-700 h-8 w-8 p-0"
                  onClick={(e) => {
                    e.stopPropagation();
                    onDelete(project._id);
                  }}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </>
            )}
          </div>
        </div>
        <div className="flex items-center gap-2 mt-2">
          <Badge variant="secondary" className={getStatusBadgeClass(project.status)}>
            {project.status || 'Unknown'}
          </Badge>
          <div className="flex items-center text-sm text-muted-foreground">
            <Calendar className="mr-1 h-3 w-3" />
            {formatDisplayDate(project.created_at)}
          </div>
        </div>
      </CardHeader>
      <CardContent className="flex-grow">
        <CardDescription className="line-clamp-3 text-sm">
          {project.description || "No description provided."}
        </CardDescription>
      </CardContent>
    </Card>
  );
};













// frontend/app/component/projects/project-management.tsx
"use client";
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Plus, Grid, List } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert } from "lucide-react";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { useProjects } from "@/hooks/use-projects";
import { useAuth } from "@/provider/auth-context";
import { projectSchema, type ProjectEntry } from "@/lib/schema";
import { z } from "zod";
import { ProjectFilterControls } from "./ProjectFilterControls";
import { ProjectTable } from "./ProjectTable";
import { ProjectCard } from "./project-card"; // Import only the component
import { ProjectForm } from "./ProjectForm";
import { useProjectFilters } from "./hooks/useProjectFilters";
import { useNavigate, useSearchParams } from "react-router-dom";

// Define the props interface here since it's not exported from project-card.tsx
interface ProjectCardProps {
  project: ProjectEntry;
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
  canEdit: boolean;
}

const ProjectManagement = () => {
  const { user } = useAuth();
  const { projects, isLoading, error, createProject, updateProject, deleteProject } = useProjects();
  const [showForm, setShowForm] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState<string | null>(null);
  const [currentProject, setCurrentProject] = useState<ProjectEntry | null>(null);
  const [sortBy, setSortBy] = useState<'newest' | 'oldest'>('newest');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [dateRange, setDateRange] = useState<{ startDate: Date | undefined; endDate: Date | undefined; }>({ startDate: undefined, endDate: undefined });
  const [viewMode, setViewMode] = useState<'table' | 'cards'>('table');
  
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  // Get filter from URL parameters
  useEffect(() => {
    const filterParam = searchParams.get('filter');
    console.log("Filter param from URL:", filterParam); // Debug log
    
    if (filterParam) {
      if (filterParam.toLowerCase() === 'all') {
        setStatusFilter('all');
      } else if (['ongoing', 'completed', 'pending', 'archived'].includes(filterParam.toLowerCase())) {
        // Convert to proper case (first letter capitalized)
        const properCaseFilter = filterParam.charAt(0).toUpperCase() + filterParam.slice(1);
        console.log("Setting status filter to:", properCaseFilter); // Debug log
        setStatusFilter(properCaseFilter);
      }
    }
  }, [searchParams]);
  
  const { filteredAndSortedProjects, hasProjects, hasFilteredProjects } = useProjectFilters({
    projects,
    sortBy,
    statusFilter,
    searchTerm,
    dateRange: {
      startDate: dateRange.startDate ? dateRange.startDate.toISOString().split('T')[0] : undefined,
      endDate: dateRange.endDate ? dateRange.endDate.toISOString().split('T')[0] : undefined
    }
  });
  
  // Debug logs
  useEffect(() => {
    console.log("Current status filter:", statusFilter);
    console.log("Filtered projects:", filteredAndSortedProjects);
    console.log("All projects:", projects);
    console.log("Projects with ongoing status:", projects.filter(p => p.status === 'Ongoing'));
    console.log("Projects with completed status:", projects.filter(p => p.status === 'Completed'));
    console.log("Projects with pending status:", projects.filter(p => p.status === 'Pending'));
  }, [statusFilter, filteredAndSortedProjects, projects]);
  
  const handleAddClick = () => {
    // Only managers can create projects
    if (user?.role !== "manager") {
      alert("Only managers can create projects");
      return;
    }
    
    setCurrentProject(null);
    setShowForm(true);
  };
  
  const handleEditClick = (project: ProjectEntry) => {
    // Only managers can edit projects
    if (user?.role !== "manager") {
      alert("Only managers can edit projects");
      return;
    }
    
    setCurrentProject(project);
    setShowForm(true);
  };
  
  const handleDeleteClick = (_id: string) => {
    // Only managers can delete projects
    if (user?.role !== "manager") {
      alert("Only managers can delete projects");
      return;
    }
    
    setProjectToDelete(_id);
    setShowDeleteDialog(true);
  };
  
  const handleConfirmDelete = async () => {
    if (projectToDelete) {
      await deleteProject(projectToDelete);
    }
    setShowDeleteDialog(false);
    setProjectToDelete(null);
  };
  
  const handleSubmit = async (values: z.infer<typeof projectSchema>) => {
    if (currentProject) {
      await updateProject(currentProject._id, values);
    } else {
      await createProject(values);
    }
    setShowForm(false);
  };
  
  // Handle sort toggle
  const toggleSort = () => {
    setSortBy(sortBy === 'newest' ? 'oldest' : 'newest');
  };
  
  // Handle project click
  const handleProjectClick = (projectId: string) => {
    navigate(`/projects/${projectId}`);
  };
  
  // Handle status filter change
  const handleStatusFilterChange = (status: string) => {
    console.log("Status filter changed to:", status); // Debug log
    setStatusFilter(status);
    // Update URL to reflect the current filter
    const params = new URLSearchParams(searchParams);
    if (status === 'all') {
      params.delete('filter');
    } else {
      params.set('filter', status.toLowerCase());
    }
    console.log("Updating URL to:", `/projects?${params.toString()}`); // Debug log
    navigate(`/projects?${params.toString()}`, { replace: true });
  };
  
  // Determine if user can create projects
  const canCreateProjects = user?.role === "manager";
  
  return (
    <div className="container mx-auto p-4 pt-0">
      {/* Header with no bottom margin */}
      <div className="flex items-center justify-between mb-0">
        <h3 className="text-xl font-bold">
          {canCreateProjects ? "Project Management" : "Projects"}
        </h3>
        <div className="flex items-center gap-2">
          {canCreateProjects && (
            <Button onClick={handleAddClick} className="flex items-center gap-1 text-sm py-1 h-8">
              <Plus className="h-3 w-3" />
              Create Project
            </Button>
          )}
          <Button variant="outline" size="sm" onClick={() => setViewMode(viewMode === 'table' ? 'cards' : 'table')} className="flex items-center gap-1">
            {viewMode === 'table' ? (
              <>
                <Grid className="h-4 w-4" />
                Cards
              </>
            ) : (
              <>
                <List className="h-4 w-4" />
                Table
              </>
            )}
          </Button>
        </div>
      </div>
      
      {/* Filter Controls */}
      <ProjectFilterControls
        sortBy={sortBy}
        statusFilter={statusFilter}
        searchTerm={searchTerm}
        dateRange={dateRange}
        onSortChange={setSortBy}
        onStatusFilterChange={handleStatusFilterChange}
        onSearchChange={setSearchTerm}
        onDateRangeChange={setDateRange}
      />
      
      {error && (
        <Alert variant="destructive" className="mb-2">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {/* Scrollable content container */}
      <div className="overflow-y-auto max-h-[calc(100vh-200px)]">
        {isLoading ? (
          <div className="flex items-center justify-center h-32">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
          </div>
        ) : (
          <>
            {viewMode === 'table' ? (
              <ProjectTable
                projects={filteredAndSortedProjects}
                onEdit={handleEditClick}
                onDelete={handleDeleteClick}
                onProjectClick={handleProjectClick}
                onSortToggle={toggleSort}
                sortBy={sortBy}
                isLoading={isLoading}
                hasProjects={hasProjects}
                hasFilteredProjects={hasFilteredProjects}
                canEdit={canCreateProjects}
              />
            ) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {filteredAndSortedProjects.map((project) => (
                  <ProjectCard 
                    key={project._id} 
                    project={project} 
                    onEdit={handleEditClick} 
                    onDelete={handleDeleteClick}
                    onProjectClick={handleProjectClick}
                    canEdit={canCreateProjects}
                  />
                ))}
              </div>
            )}
          </>
        )}
      </div>
      
      {/* Form for Adding & Editing Projects - Only for Managers */}
      {canCreateProjects && (
        <ProjectForm
          isOpen={showForm}
          onClose={() => setShowForm(false)}
          project={currentProject}
          onSubmit={handleSubmit}
        />
      )}
      
      {/* Custom Confirmation Dialog for Deleting - Only for Managers */}
      {canCreateProjects && (
        <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete the project.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
};

export default ProjectManagement;









\\/frontend/app/components/projects/ProjectDetail.tsx
import React, { useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ArrowLeft, Plus, Calendar, CheckCircle, Circle, Trash2, Edit, Grid, List, MoreHorizontal } from "lucide-react";
import { format } from "date-fns";
import { useProjectDetail } from "@/hooks/useProjectDetail";
import { useStages } from "@/hooks/use-stages";
import { useAuth } from "@/provider/auth-context";
import { ProjectStageForm } from "./ProjectStageForm";
import { ConnectionForm } from "./ConnectionForm";
import { ProjectStageCard } from "./ProjectStageCard";
import { ProjectStageTable } from "./ProjectStageTable";
import { CustomStageForm } from "./CustomStageForm";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { toast } from "sonner";
import type { StageEntry } from "@/lib/schema";

const updateStageSchema = z.object({
  stage_name: z.string().min(1, { message: "Stage name is required" }),
  description: z.string().optional(),
});

type UpdateStageValues = z.infer<typeof updateStageSchema>;

export const ProjectDetail: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  const { user } = useAuth();
  
  const [showStageForm, setShowStageForm] = useState(false);
  const [showCustomStageForm, setShowCustomStageForm] = useState(false);
  const [showConnectionForm, setShowConnectionForm] = useState(false);
  const [viewMode, setViewMode] = useState<'cards' | 'table'>('cards');
  const [editingStage, setEditingStage] = useState<string | null>(null);
  const [preSelectedStageId, setPreSelectedStageId] = useState<string | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [stageToDelete, setStageToDelete] = useState<{ stageId: string; isCustom: boolean } | null>(null);
  const [showUpdateDialog, setShowUpdateDialog] = useState(false);
  const [stageToUpdate, setStageToUpdate] = useState<StageEntry | null>(null);
  
  const {
    project,
    stages,
    connections,
    availableStages,
    isLoading,
    error,
    addStageToProject,
    updateProjectStage,
    deleteProjectStage,
    createStageConnection
  } = useProjectDetail(projectId || null);
  
  // Use the useStages hook with projectId to get both global and custom stages
  const { stages: allStages, refetch: refetchStages, deleteCustomStageFromProject } = useStages(projectId || undefined);
  
  // Update the availableStages to include both global and custom stages
  const filteredAvailableStages = allStages.filter(stage => 
    !project?.stages?.some((projectStage: any) => projectStage.stage._id === stage._id)
  );
  
  // Determine if user can edit this project
  const canEditProject = user?.role === "manager" && project?.owner._id === user._id;
  
  const handleAddStage = (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    addStageToProject(stageId, status, startDate, completionDate);
    setShowStageForm(false);
    setPreSelectedStageId(null);
    refetchStages(); // Refresh stages after adding
  };
  
  const handleStageClick = (stageId: string) => {
    if (!canEditProject) return;
    setPreSelectedStageId(stageId);
    setShowStageForm(true);
  };
  
const handleUpdateStage = (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
  updateProjectStage(stageId, status, startDate, completionDate);
  setEditingStage(null);
  
  };
  
  const handleCreateConnection = (fromStageId: string, toStageId: string) => {
    createStageConnection(fromStageId, toStageId);
    setShowConnectionForm(false);
  };
  
  const handleMarkComplete = (stageId: string) => {
    if (!canEditProject) return;
    const stage = stages.find(s => s._id === stageId);
    if (stage) {
      // Show completion date picker
      setEditingStage(stageId);
    }
  };
  


  // Add this function to handle project status update
const handleMarkProjectCompleted = async () => {
  if (!project || !canEditProject) return;    
  try {
    const response = await fetch(`${import.meta.env.VITE_API_URL}/projects/${project._id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${localStorage.getItem("token")}`,
      },
      body: JSON.stringify({ status: "Completed" }),
    });
    
    if (!response.ok) {
      throw new Error("Failed to update project status");
    }
    
    toast.success("Project marked as completed");
    // Refresh the page to show the updated project status
    window.location.reload();
  } catch (error) {
    toast.error("Failed to update project status");
  }
};
  




  const handleDeleteClick = (stageId: string, isCustom: boolean) => {
    if (!canEditProject) return;
    setStageToDelete({ stageId, isCustom });
    setShowDeleteDialog(true);
  };
  
  const handleConfirmDelete = async () => {
    if (!stageToDelete || !projectId) return;
    
    try {
      if (stageToDelete.isCustom) {
        // Delete custom stage from database
        await deleteCustomStageFromProject(stageToDelete.stageId, projectId);
        toast.success("Custom stage deleted successfully");
      } else {
        // Just remove from project
        await deleteProjectStage(stageToDelete.stageId);
        toast.success("Stage removed from project");
      }
      
      setShowDeleteDialog(false);
      setStageToDelete(null);
    } catch (error) {
      toast.error("Failed to delete stage");
    }
  };
  
  const handleUpdateClick = (stage: StageEntry) => {
    if (!canEditProject) return;
    setStageToUpdate(stage);
    setShowUpdateDialog(true);
  };
  
  const updateForm = useForm<UpdateStageValues>({
    resolver: zodResolver(updateStageSchema),
    defaultValues: {
      stage_name: stageToUpdate?.stage_name || "",
      description: stageToUpdate?.description || "",
    },
    values: {
      stage_name: stageToUpdate?.stage_name || "",
      description: stageToUpdate?.description || "",
    },
  });
  
  const handleUpdateSubmit = async (values: UpdateStageValues) => {
    if (!stageToUpdate) return;
    
    try {
      const response = await fetch(`${import.meta.env.VITE_API_URL}/stages/update-stage/${stageToUpdate._id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(values),
      });
      
      if (!response.ok) {
        throw new Error("Failed to update stage");
      }
      
      toast.success("Stage updated successfully");
      setShowUpdateDialog(false);
      setStageToUpdate(null);
      refetchStages();
    } catch (error) {
      toast.error("Failed to update stage");
    }
  };
  
  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) return "Not set";
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }
  
  if (error || !project) {
    return (
      <div className="container mx-auto p-4">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            {error || "Project not found"}
          </AlertDescription>
        </Alert>
        <Button className="mt-4" onClick={() => navigate("/projects")}>
          <ArrowLeft className="mr-2 h-4 w-4" /> Back to Projects
        </Button>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto p-4">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center">
          <Button variant="ghost" onClick={() => navigate("/projects")} className="mr-4">
            <ArrowLeft className="h-4 w-4" />
          </Button>
          <div>
            <h1 className="text-2xl font-bold">{project.project_name}</h1>
            <div className="flex items-center mt-1">
              <Badge className={getStatusColor(project.status || '')}>
                {project.status}
              </Badge>
              <span className="text-sm text-muted-foreground ml-2">
                Created: {formatDisplayDate(project.created_at)}
              </span>
              {project.owner && (
                <span className="text-sm text-muted-foreground ml-2">
                  Owner: {project.owner.name}
                </span>
              )}
            </div>
          </div>
        </div>
        
        <div className="flex gap-2">
          {/* View mode toggle - available for all users */}
          <Button 
            variant="outline" 
            onClick={() => setViewMode(viewMode === 'cards' ? 'table' : 'cards')}
            className="flex items-center gap-1"
          >
            {viewMode === 'cards' ? (
              <>
                <List className="h-4 w-4" />
                Table
              </>
            ) : (
              <>
                <Grid className="h-4 w-4" />
                Card 
              </>
            )}
          </Button>
          
          {canEditProject && project?.status !== 'Completed' && (
            <>
              <Button 
                variant="default" 
                onClick={handleMarkProjectCompleted}
                className="flex items-center gap-1 bg-green-600 hover:bg-green-700"
              >
                <CheckCircle className="h-4 w-4" />
                Mark as Completed
              </Button>
              
              <Button onClick={() => {
                setShowStageForm(true);
                setPreSelectedStageId(null);
              }}>
                <Plus className="mr-2 h-4 w-4" /> Add Stage
              </Button>
              
              <Button 
                variant="outline"
                onClick={() => setShowCustomStageForm(true)}
              >
                <Plus className="mr-2 h-4 w-4" /> Create Custom Stage
              </Button>
              
              <Button 
                variant="outline" 
                onClick={() => setShowConnectionForm(true)}
                disabled={stages.length < 2}
              >
                Connect Stages
              </Button>
            </>
          )}
        </div>
      </div>
      
      {/* Available Stages - Only show if project is not completed */}
      {canEditProject && project?.status !== 'Completed' && filteredAvailableStages.length > 0 && (
        <Card className="mb-6">
          <CardHeader>
            <CardTitle className="text-lg">Available Stages</CardTitle>
            <p className="text-sm text-muted-foreground">Click on a stage to add it to the project</p>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
              {filteredAvailableStages.map(stage => (
                <div 
                  key={stage._id}
                  className="p-3 border rounded-lg cursor-pointer hover:bg-muted transition-colors hover:shadow-sm relative group"
                  onClick={() => handleStageClick(stage._id)}
                >
                  <div className="font-medium line-clamp-2 flex items-center gap-2">
                    {stage.stage_name}
                    {stage.isCustom && (
                      <Badge variant="secondary" className="bg-purple-100 text-purple-800">
                        Custom
                      </Badge>
                    )}
                  </div>
                  {stage.description && (
                    <div className="text-sm text-muted-foreground mt-1 line-clamp-2">
                      {stage.description}
                    </div>
                  )}
                  
                  {/* Delete button for custom stages */}
                  {canEditProject && stage.isCustom && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity text-red-500 hover:text-red-700"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleDeleteClick(stage._id, true);
                      }}
                    >
                      <Trash2 className="h-3 w-3" />
                    </Button>
                  )}
                  
                  {/* Update button for custom stages */}
                  {canEditProject && stage.isCustom && (
                    <Button
                      variant="ghost"
                      size="sm"
                      className="absolute top-1 right-8 opacity-0 group-hover:opacity-100 transition-opacity text-yellow-500 hover:text-yellow-700"
                      onClick={(e) => {
                        e.stopPropagation();
                        handleUpdateClick(stage);
                      }}
                    >
                      <Edit className="h-3 w-3" />
                    </Button>
                  )}
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Show a message when project is completed */}
      {project?.status === 'Completed' && (
        <Card className="mb-6">
          <CardContent className="pt-6">
            <div className="flex items-center justify-center text-center">
              <CheckCircle className="h-12 w-12 text-green-500 mr-4" />
              <div>
                <h3 className="text-lg font-semibold">Project Completed</h3>
                <p className="text-muted-foreground">
                  This project has been marked as completed. No further changes can be made.
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Project Stages */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg flex items-center">
            Project Stages
            <Badge variant="secondary" className="ml-2">
              {stages.length} {stages.length === 1 ? 'Stage' : 'Stages'}
            </Badge>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {stages.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No stages added to this project yet.
              {canEditProject && project?.status !== 'Completed' && " Click on available stages above to add them."}
            </div>
          ) : viewMode === 'cards' ? (
            <div className="relative">
              {/* Connection lines for card view */}
              <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ zIndex: 0 }}>
                {connections.map((conn, index) => {
                  const fromElement = document.getElementById(`stage-card-${conn.from_stage._id}`);
                  const toElement = document.getElementById(`stage-card-${conn.to_stage._id}`);
                  
                  if (!fromElement || !toElement) return null;
                  
                  const fromRect = fromElement.getBoundingClientRect();
                  const toRect = toElement.getBoundingClientRect();
                  
                  const containerRect = fromElement.parentElement?.getBoundingClientRect();
                  if (!containerRect) return null;
                  
                  const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
                  const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                  const x2 = toRect.left + toRect.width / 2 - containerRect.left;
                  const y2 = toRect.top + toRect.height / 2 - containerRect.top;
                  
                  return (
                    <line 
                      key={index}
                      x1={x1}
                      y1={y1}
                      x2={x2}
                      y2={y2}
                      stroke="#94a3b8"
                      strokeWidth="2"
                      markerEnd="url(#arrowhead)"
                    />
                  );
                })}
                <defs>
                  <marker 
                    id="arrowhead" 
                    markerWidth="10" 
                    markerHeight="7" 
                    refX="9" 
                    refY="3.5" 
                    orient="auto"
                  >
                    <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                  </marker>
                </defs>
              </svg>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 relative" style={{ zIndex: 1 }}>
                {stages.map(stage => (
                  <ProjectStageCard 
  key={stage._id}
  stage={stage}
  onEdit={() => canEditProject && project?.status !== 'Completed' && setEditingStage(stage._id)}
  onDelete={() => canEditProject && project?.status !== 'Completed' && handleDeleteClick(stage._id, false)}
  onMarkComplete={() => canEditProject && project?.status !== 'Completed' && handleMarkComplete(stage._id)}
  canEdit={canEditProject}
  projectStatus={project?.status}
/>

                ))}
              </div>
            </div>
          ) : (
            <ProjectStageTable 
  stages={stages}
  onEdit={(stageId) => canEditProject && project?.status !== 'Completed' && setEditingStage(stageId)}
  onDelete={(stageId) => canEditProject && project?.status !== 'Completed' && handleDeleteClick(stageId, false)}
  onMarkComplete={(stageId) => canEditProject && project?.status !== 'Completed' && handleMarkComplete(stageId)}
  canEdit={canEditProject}
  projectStatus={project?.status}
/>
          )}
        </CardContent>
      </Card>
      
      {/* Add Stage Form - Only for Managers */}
      {canEditProject && showStageForm && (
        <ProjectStageForm
          availableStages={filteredAvailableStages}
          projectId={projectId}
          onSubmit={handleAddStage}
          onCancel={() => {
            setShowStageForm(false);
            setPreSelectedStageId(null);
          }}
          preSelectedStageId={preSelectedStageId || undefined}
        />
      )}
      
      {/* Custom Stage Form - Only for Managers */}
      {canEditProject && showCustomStageForm && (
        <CustomStageForm
          projectId={projectId || ""}
          onSuccess={() => {
            setShowCustomStageForm(false);
            refetchStages();
          }}
          onCancel={() => setShowCustomStageForm(false)}
        />
      )}
      
      {/* Edit Stage Form - Only for Managers */}
      {canEditProject && editingStage && (
        <ProjectStageForm
          stage={stages.find(s => s._id === editingStage)}
          isEditing={true}
          projectId={projectId}
          onSubmit={(stageId, status, startDate, completionDate) => 
            handleUpdateStage(editingStage, status, startDate, completionDate)
          }
          onCancel={() => setEditingStage(null)}
        />
      )}
      
      {/* Connection Form - Only for Managers */}
      {canEditProject && showConnectionForm && (
        <ConnectionForm
          stages={stages}
          connections={connections}
          onSubmit={handleCreateConnection}
          onCancel={() => setShowConnectionForm(false)}
        />
      )}
      
      {/* Delete Confirmation Dialog */}
      {canEditProject && (
        <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Confirm Removal</DialogTitle>
              <DialogDescription>
                {stageToDelete?.isCustom 
                  ? "This will permanently delete the custom stage from the database. This action cannot be undone."
                  : "This will remove the stage from the project. The stage will still be available in the system."
                }
              </DialogDescription>
            </DialogHeader>
            <DialogFooter>
              <Button variant="outline" onClick={() => setShowDeleteDialog(false)}>
                Cancel
              </Button>
              <Button variant="destructive" onClick={handleConfirmDelete}>
                {stageToDelete?.isCustom ? "Delete Permanently" : "Remove from Project"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
      
      {/* Update Stage Dialog */}
      {canEditProject && (
        <Dialog open={showUpdateDialog} onOpenChange={setShowUpdateDialog}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Update Custom Stage</DialogTitle>
              <DialogDescription>
                Update the custom stage details below.
              </DialogDescription>
            </DialogHeader>
            <Form {...updateForm}>
              <form onSubmit={updateForm.handleSubmit(handleUpdateSubmit)} className="space-y-4">
                <FormField
                  control={updateForm.control}
                  name="stage_name"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Stage Name</FormLabel>
                      <FormControl>
                        <Input placeholder="Enter stage name" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={updateForm.control}
                  name="description"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Description</FormLabel>
                      <FormControl>
                        <Textarea 
                          placeholder="Enter stage description" 
                          className="min-h-[100px]"
                          {...field} 
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <DialogFooter>
                  <Button type="button" variant="outline" onClick={() => setShowUpdateDialog(false)}>
                    Cancel
                  </Button>
                  <Button type="submit">
                    Update Stage
                  </Button>
                </DialogFooter>
              </form>
            </Form>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
};










// frontend/app/component/projects/ProjectFilterControls.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { CalendarIcon, Search, X } from 'lucide-react';
import { format } from 'date-fns';
import { cn } from '@/lib/utils';
import { SearchBar } from '@/components/ui/search-bar';

interface ProjectFilterControlsProps {
  sortBy: 'newest' | 'oldest';
  statusFilter: string;
  searchTerm: string;
  dateRange: {
    startDate: Date | undefined;
    endDate: Date | undefined;
  };
  onSortChange: (sortBy: 'newest' | 'oldest') => void;
  onStatusFilterChange: (statusFilter: string) => void;
  onSearchChange: (searchTerm: string) => void;
  onDateRangeChange: (dateRange: { startDate: Date | undefined; endDate: Date | undefined }) => void;
}

export const ProjectFilterControls: React.FC<ProjectFilterControlsProps> = ({
  sortBy,
  statusFilter,
  searchTerm,
  dateRange,
  onSortChange,
  onStatusFilterChange,
  onSearchChange,
  onDateRangeChange
}) => {
  const toggleSort = () => {
    onSortChange(sortBy === 'newest' ? 'oldest' : 'newest');
  };
  
  const clearDateRange = () => {
    onDateRangeChange({ startDate: undefined, endDate: undefined });
  };
  
  // Handle start date selection
  const handleStartDateSelect = (date: Date | undefined) => {
    onDateRangeChange({ ...dateRange, startDate: date });
  };
  
  // Handle end date selection
  const handleEndDateSelect = (date: Date | undefined) => {
    onDateRangeChange({ ...dateRange, endDate: date });
  };
  
  // Handle status filter change
  const handleStatusFilterChange = (value: string) => {
    console.log("ProjectFilterControls handleStatusFilterChange:", value); // Debug log
    onStatusFilterChange(value);
  };
  
  return (
    <div className="flex flex-wrap gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
      {/* Search Input using the reusable SearchBar component */}
      <div className="flex-1 min-w-[250px]">
        <SearchBar 
          placeholder="Search projects..." 
          value={searchTerm} 
          onChange={onSearchChange} 
        />
      </div>
      
      {/* Sort Button */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Sort:</span>
        <Button variant="outline" size="sm" onClick={toggleSort} className="flex items-center gap-1">
          {sortBy === 'newest' ? 'Newest' : 'Oldest'}
          <CalendarIcon className="h-3 w-3" />
        </Button>
      </div>
      
      {/* Status Filter */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Status:</span>
        <Select value={statusFilter} onValueChange={handleStatusFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All statuses" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Statuses</SelectItem>
            <SelectItem value="Pending">Pending</SelectItem>
            <SelectItem value="Ongoing">Ongoing</SelectItem>
            <SelectItem value="Completed">Completed</SelectItem>
            <SelectItem value="Archived">Archived</SelectItem>
          </SelectContent>
        </Select>
      </div>
      
      {/* Date Range Filter */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Date Range:</span>
        <div className="flex gap-2">
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className={cn(
                "w-[140px] justify-start text-left font-normal",
                !dateRange.startDate && "text-muted-foreground"
              )}>
                {dateRange.startDate ? (
                  format(dateRange.startDate, "MMM dd, yyyy")
                ) : (
                  <span>Start date</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={dateRange.startDate}
                onSelect={handleStartDateSelect}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className={cn(
                "w-[140px] justify-start text-left font-normal",
                !dateRange.endDate && "text-muted-foreground"
              )}>
                {dateRange.endDate ? (
                  format(dateRange.endDate, "MMM dd, yyyy")
                ) : (
                  <span>End date</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={dateRange.endDate}
                onSelect={handleEndDateSelect}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          
          {(dateRange.startDate || dateRange.endDate) && (
            <Button variant="ghost" size="sm" onClick={clearDateRange} className="text-gray-500">
              <X className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </div>
  );
};









// frontend/app/components/projects/projectForm.tsx
import React, { useEffect, useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { projectSchema, type ProjectEntry } from "@/lib/schema";
import { z } from "zod";

interface ProjectFormProps {
  isOpen: boolean;
  onClose: () => void;
  project?: ProjectEntry | null;
  onSubmit: (values: z.infer<typeof projectSchema>) => void;
}

// Helper function to format date as YYYY-MM-DD without timezone conversion
const formatDateForSubmission = (date: Date): string => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

export const ProjectForm: React.FC<ProjectFormProps> = ({
  isOpen,
  onClose,
  project,
  onSubmit
}) => {
  const [date, setDate] = useState<Date | undefined>(undefined);
  const form = useForm<z.infer<typeof projectSchema>>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      project_name: "",
      description: "",
      status: "Pending",
      created_at: new Date().toISOString().split('T')[0],
    },
  });

  // Reset form when project changes or dialog opens/closes
  useEffect(() => {
    if (isOpen && project) {
      // Editing existing project
      const projectDate = new Date(project.created_at);
      setDate(projectDate);
      form.reset({
        project_name: project.project_name || "",
        description: project.description || "",
        status: project.status || "Pending",
        created_at: project.created_at,
      });
    } else if (isOpen) {
      // Creating new project
      const today = new Date();
      setDate(today);
      form.reset({
        project_name: "",
        description: "",
        status: "Pending",
        created_at: formatDateForSubmission(today),
      });
    } else {
      // Dialog closed
      form.reset();
      setDate(undefined);
    }
  }, [isOpen, project, form]);

  // Handle date selection from calendar
  const handleDateSelect = (selectedDate: Date | undefined) => {
    setDate(selectedDate);
    if (selectedDate) {
      // Format date as YYYY-MM-DD for form submission without timezone conversion
      const formattedDate = formatDateForSubmission(selectedDate);
      form.setValue("created_at", formattedDate);
    }
  };

  const handleSubmit = (values: z.infer<typeof projectSchema>) => {
    onSubmit(values);
    form.reset();
    setDate(undefined);
  };

  const handleCancel = () => {
    form.reset();
    setDate(undefined);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleCancel}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>
            {project ? "Edit Project" : "Create Project"}
          </DialogTitle>
          <DialogDescription>
            {project ? "Update the project details below." : "Fill in the details to create a new project."}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)}>
            <FormField
              control={form.control}
              name="project_name"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Project Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter Project Name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea placeholder="Enter Project Description" className="min-h-[100px]" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="status"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Status</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a status" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="Pending">Pending</SelectItem>
                      <SelectItem value="Ongoing">Ongoing</SelectItem>
                      <SelectItem value="Completed">Completed</SelectItem>
                      <SelectItem value="Archived">Archived</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="created_at"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Created At</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant={"outline"}
                          className={cn(
                            "w-full pl-3 text-left font-normal",
                            !date && "text-muted-foreground"
                          )}
                        >
                          {date ? (
                            format(date, "PPP")
                          ) : (
                            <span>Pick a date</span>
                          )}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={date}
                        onSelect={handleDateSelect}
                        disabled={(date) => date < new Date("1900-01-01")}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter className="mt-4">
              <Button type="submit">
                {project ? "Update Project" : "Create Project"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};







\\frontend/app/components/projects/ProjectStageCard.tsx

import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Trash2, Edit, CheckCircle, MoreHorizontal } from "lucide-react";
import { format } from "date-fns";
import { type ProjectStageEntry } from "@/lib/schema";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface ProjectStageCardProps {
  stage: ProjectStageEntry;
  onEdit: () => void;
  onDelete: () => void;
  onMarkComplete: () => void;
  canEdit: boolean;
  projectStatus?: string; // Add this prop
}

export const ProjectStageCard: React.FC<ProjectStageCardProps> = ({ 
  stage, 
  onEdit, 
  onDelete,
  onMarkComplete,
  canEdit,
  projectStatus = 'Ongoing' // Default value
}) => {
  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) return "Not set";
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  const canEditStage = canEdit && projectStatus !== 'Completed';
  
  return (
    <Card 
      id={`stage-card-${stage._id}`}
      className="h-full flex flex-col"
    >
      <CardHeader className="pb-3">
        <div className="flex justify-between items-start">
          <CardTitle className="text-lg font-semibold line-clamp-2 flex items-center gap-2">
            {stage.stage.stage_name}
            {stage.stage.isCustom && (
              <Badge variant="secondary" className="bg-purple-100 text-purple-800">
                Custom
              </Badge>
            )}
          </CardTitle>
          {canEditStage && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm">
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
  <DropdownMenuItem onClick={onEdit}>
    <Edit className="mr-2 h-4 w-4" />
    Edit
  </DropdownMenuItem>
  <DropdownMenuItem onClick={onDelete} className="text-red-500">
    <Trash2 className="mr-2 h-4 w-4" />
    Remove from Project
  </DropdownMenuItem>
  {stage.status === 'Ongoing' && (
    <DropdownMenuItem onClick={onMarkComplete}>
      <CheckCircle className="mr-2 h-4 w-4" />
      Mark Stage Complete
    </DropdownMenuItem>
  )}
</DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>
        <div className="flex items-center gap-2 mt-2">
          <Badge variant="secondary" className={getStatusColor(stage.status)}>
            {stage.status}
          </Badge>
        </div>
      </CardHeader>
      <CardContent className="flex-grow">
        {stage.stage.description && (
          <p className="text-sm text-muted-foreground mb-4 line-clamp-3">
            {stage.stage.description}
          </p>
        )}
        
        <div className="space-y-2">
          <div className="text-sm">
            <span className="font-medium">Start Date: </span>
            <span>{formatDisplayDate(stage.start_date)}</span>
          </div>
          
          {stage.status === 'Completed' && (
            <div className="text-sm">
              <span className="font-medium">Completion Date: </span>
              <span>{formatDisplayDate(stage.completion_date)}</span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};










\\frontend/app/components/projects/projectStageForm.tsx
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { type StageEntry, type ProjectStageEntry } from "@/lib/schema";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";
import { Badge } from "@/components/ui/badge";

const stageFormSchema = z.object({
  stageId: z.string().min(1, { message: "Stage is required" }),
  status: z.enum(['Ongoing', 'Completed']),
  startDate: z.string().optional(),
  completionDate: z.string().optional(),
});

type StageFormValues = z.infer<typeof stageFormSchema>;

interface ProjectStageFormProps {
  availableStages?: StageEntry[];
  stage?: ProjectStageEntry;
  isEditing?: boolean;
  projectId?: string;
  onSubmit: (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => void;
  onCancel: () => void;
  preSelectedStageId?: string;
}

export const ProjectStageForm: React.FC<ProjectStageFormProps> = ({
  availableStages = [],
  stage,
  isEditing = false,
  projectId,
  onSubmit,
  onCancel,
  preSelectedStageId
}) => {
  const [status, setStatus] = useState<'Ongoing' | 'Completed'>(stage?.status || 'Ongoing');
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");
  
  const form = useForm<StageFormValues>({
    resolver: zodResolver(stageFormSchema),
    defaultValues: {
      stageId: preSelectedStageId || stage?.stage._id || '',
      status: stage?.status || 'Ongoing',
      startDate: stage?.start_date ? format(new Date(stage.start_date), 'yyyy-MM-dd') : '',
      completionDate: stage?.completion_date ? format(new Date(stage.completion_date), 'yyyy-MM-dd') : '',
    },
  });

  const watchedStatus = form.watch('status');
  
  useEffect(() => {
    if (watchedStatus) {
      setStatus(watchedStatus as 'Ongoing' | 'Completed');
    }
  }, [watchedStatus]);

  useEffect(() => {
    if (status === 'Ongoing') {
      form.setValue('completionDate', '');
    }
  }, [status, form]);

  const handleSubmit = (values: StageFormValues) => {
    if (values.status === 'Completed') {
      if (!values.startDate || !values.completionDate) {
        setAlertMessage("Both start date and completion date are required for Completed status");
        setShowAlert(true);
        return;
      }
    }
    
    if (values.status === 'Ongoing' && !values.startDate) {
      setAlertMessage("Start date is required for Ongoing status");
      setShowAlert(true);
      return;
    }
    
    setShowAlert(false);
    onSubmit(
      values.stageId,
      values.status,
      values.startDate,
      values.completionDate
    );
  };

  // Find the selected stage for display
  const selectedStage = availableStages.find(s => s._id === form.getValues('stageId')) || stage?.stage;

  return (
    <Dialog open={true} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {isEditing ? 'Edit Project Stage' : 'Add Stage to Project'}
          </DialogTitle>
          <DialogDescription>
            {isEditing
              ? "Update the stage details below."
              : "Select an existing stage to add to the project."
            }
          </DialogDescription>
        </DialogHeader>
        
        {showAlert && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{alertMessage}</AlertDescription>
          </Alert>
        )}
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
            {/* Show selected stage info when editing */}
            {isEditing && selectedStage && (
              <div className="p-3 bg-gray-50 rounded-lg">
                <div className="flex items-center justify-between">
                  <div>
                    <h4 className="font-medium">{selectedStage.stage_name}</h4>
                    {/* {selectedStage.description && (
                      <p className="text-sm text-gray-600 mt-1">{selectedStage.description}</p>
                    )} */}
                  </div>
                  {selectedStage.isCustom && (
                    <Badge variant="secondary" className="bg-purple-100 text-purple-800">
                      Custom
                    </Badge>
                  )}
                </div>
              </div>
            )}

            {/* Only show stage selection when not editing */}
            {!isEditing && (
              <FormField
                control={form.control}
                name="stageId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Select Stage</FormLabel>
                    <Select onValueChange={field.onChange} value={field.value}>
                      <FormControl>
                        <SelectTrigger className="h-auto py-2">
                          <SelectValue placeholder="Select a stage" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {availableStages.map(stage => (
                          <SelectItem key={`stage-${stage._id}`} value={stage._id} className="whitespace-normal">
                            <div className="max-w-xs">
                              <div className="whitespace-normal break-words">
                                {stage.stage_name}
                                {stage.isCustom && (
                                  <span className="ml-2 text-xs bg-blue-100 text-blue-800 px-1 py-0.5 rounded">
                                    Custom
                                  </span>
                                )}
                              </div>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}
            
            <FormField
              control={form.control}
              name="status"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Status</FormLabel>
                  <Select onValueChange={(value) => {
                    field.onChange(value);
                    setStatus(value as 'Ongoing' | 'Completed');
                    if (value === 'Ongoing') {
                      form.setValue('completionDate', '');
                    }
                  }} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="Ongoing">Ongoing</SelectItem>
                      <SelectItem value="Completed">Completed</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="startDate"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>
                    Start Date 
                    <span className="text-red-500">*</span>
                  </FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant={"outline"}
                          className={cn(
                            "w-full pl-3 text-left font-normal",
                            !field.value && "text-muted-foreground"
                          )}
                        >
                          {field.value ? (
                            format(new Date(field.value), "PPP")
                          ) : (
                            <span>Pick a date</span>
                          )}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={field.value ? new Date(field.value) : undefined}
                        onSelect={(date) => {
                          if (date) {
                            field.onChange(format(date, 'yyyy-MM-dd'));
                          }
                        }}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            {status === 'Completed' && (
              <FormField
                control={form.control}
                name="completionDate"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>
                      Completion Date <span className="text-red-500">*</span>
                    </FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-full pl-3 text-left font-normal",
                              !field.value && "text-muted-foreground"
                            )}
                          >
                            {field.value ? (
                              format(new Date(field.value), "PPP")
                            ) : (
                              <span>Pick a date</span>
                            )}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={field.value ? new Date(field.value) : undefined}
                          onSelect={(date) => {
                            if (date) {
                              field.onChange(format(date, 'yyyy-MM-dd'));
                            }
                          }}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}
            
            <DialogFooter className="mt-4">
              <Button type="button" variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button type="submit">
                {isEditing ? 'Update Stage' : 'Add Stage'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};










\\frontend/app/components/projects/ProjectStageTable.tsx

import React from "react";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Trash2, Edit, CheckCircle, MoreHorizontal } from "lucide-react";
import { format } from "date-fns";
import { type ProjectStageEntry } from "@/lib/schema";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface ProjectStageTableProps {
  stages: ProjectStageEntry[];
  onEdit: (stageId: string) => void;
  onDelete: (stageId: string) => void;
  onMarkComplete: (stageId: string) => void;
  canEdit: boolean;
  projectStatus?: string; // Add this prop
}

export const ProjectStageTable: React.FC<ProjectStageTableProps> = ({
  stages,
  onEdit,
  onDelete,
  onMarkComplete,
  canEdit,
  projectStatus = 'Ongoing' // Default value
}) => {
  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) return "Not set";
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  // Sort stages by date (oldest first)
  const sortedStages = [...stages].sort((a, b) => {
    const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
    const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
    return dateA - dateB;
  });
  
  const canEditStage = canEdit && projectStatus !== 'Completed';
  
  return (
    <div className="rounded-md border overflow-hidden">
      <div className="overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[40px] min-w-[40px]">#</TableHead>
              <TableHead className="w-[200px] min-w-[150px] max-w-[250px]">Stage Name</TableHead>
              <TableHead className="w-[250px] min-w-[200px] max-w-[300px]">Description</TableHead>
              <TableHead className="w-[100px] min-w-[80px]">Status</TableHead>
              <TableHead className="w-[120px] min-w-[100px]">Start Date</TableHead>
              <TableHead className="w-[140px] min-w-[120px]">Completion Date</TableHead>
              {canEditStage && <TableHead className="w-[80px] min-w-[80px] text-right">Actions</TableHead>}
            </TableRow>
          </TableHeader>
          <TableBody>
            {sortedStages.map((stage, index) => (
              <TableRow key={stage._id}>
                <TableCell className="w-[40px] min-w-[40px]">{index + 1}</TableCell>
                <TableCell className="w-[200px] min-w-[150px] max-w-[250px] whitespace-normal break-words">
                  <div className="flex items-center gap-2">
                    {stage.stage.stage_name}
                    {stage.stage.isCustom && (
                      <Badge variant="secondary" className="bg-purple-100 text-purple-800">
                        Custom
                      </Badge>
                    )}
                  </div>
                </TableCell>
                <TableCell className="w-[250px] min-w-[200px] max-w-[300px] whitespace-normal break-words">
                  {stage.stage.description || "No description"}
                </TableCell>
                <TableCell className="w-[100px] min-w-[80px]">
                  <Badge className={getStatusColor(stage.status)}>
                    {stage.status}
                  </Badge>
                </TableCell>
                <TableCell className="w-[120px] min-w-[100px]">
                  {formatDisplayDate(stage.start_date)}
                </TableCell>
                <TableCell className="w-[140px] min-w-[120px]">
                  {formatDisplayDate(stage.completion_date)}
                </TableCell>
                {canEditStage && (
                  <TableCell className="w-[80px] min-w-[80px] text-right">
                    <DropdownMenu>
                      <DropdownMenuTrigger asChild>
                        <Button variant="ghost" size="sm">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </DropdownMenuTrigger>
                      <DropdownMenuContent align="end">
  <DropdownMenuItem onClick={() => onEdit(stage._id)}>
    <Edit className="mr-2 h-4 w-4" />
    Edit
  </DropdownMenuItem>
  <DropdownMenuItem onClick={() => onDelete(stage._id)} className="text-red-500">
    <Trash2 className="mr-2 h-4 w-4" />
    {stage.stage.isCustom ? "Delete Permanently" : "Remove from Project"}
  </DropdownMenuItem>
  {stage.status === 'Ongoing' && (
    <DropdownMenuItem onClick={() => onMarkComplete(stage._id)}>
      <CheckCircle className="mr-2 h-4 w-4" />
      Mark Stage Complete
    </DropdownMenuItem>
  )}
</DropdownMenuContent>
                    </DropdownMenu>
                  </TableCell>
                )}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>
    </div>
  );
};












\\frontend/app/components/projects/projectTable.tsx
import React from 'react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { ArrowUpDown, Pencil, Trash2, Eye } from "lucide-react";
import { format } from "date-fns";
import { type ProjectEntry } from "@/lib/schema";

interface ProjectTableProps {
  projects: ProjectEntry[];
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
  onSortToggle: () => void;
  sortBy: 'newest' | 'oldest';
  isLoading: boolean;
  hasProjects: boolean;
  hasFilteredProjects: boolean;
  canEdit: boolean;
}

export const ProjectTable: React.FC<ProjectTableProps> = ({ 
  projects, 
  onEdit, 
  onDelete,
  onProjectClick,
  onSortToggle, 
  sortBy, 
  isLoading, 
  hasProjects, 
  hasFilteredProjects,
  canEdit
}) => {
  // Format date for display in the table
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  // Get status badge color based on status value
  const getStatusBadgeClass = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800'; // Default for undefined or other values
    }
  };
  
  if (isLoading) {
    return <div>Loading projects...</div>;
  }
  
  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-[50px]">#</TableHead>
            <TableHead className="w-[200px]">Project Name</TableHead>
            <TableHead className="w-[300px]">Description</TableHead>
            <TableHead className="w-[120px]">Status</TableHead>
            <TableHead className="w-[120px]">
              <Button variant="ghost" className="h-auto p-0 font-semibold flex items-center gap-1" onClick={onSortToggle}>
                Created At <ArrowUpDown className="h-3 w-3" />
              </Button>
            </TableHead>
            <TableHead className="w-[100px] text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {projects.length === 0 ? (
            <TableRow>
              <TableCell colSpan={6} className="text-center h-32">
                {hasProjects ? "No projects match the selected filters." : "No projects found."}
              </TableCell>
            </TableRow>
          ) : (
            projects.map((project, index) => (
              <TableRow 
                key={project._id} 
                className="cursor-pointer hover:bg-muted/50"
                onClick={() => onProjectClick(project._id)}
              >
                <TableCell>{index + 1}</TableCell>
                <TableCell className="whitespace-normal break-words" title={project.project_name}>
                  {project.project_name}
                </TableCell>
                <TableCell className="whitespace-normal break-words" title={project.description}>
                  {project.description}
                </TableCell>
                <TableCell>
                  <div className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusBadgeClass(project.status)}`}>
                    {project.status || 'Unknown'}
                  </div>
                </TableCell>
                <TableCell>
                  {formatDisplayDate(project.created_at)}
                </TableCell>
                <TableCell className="text-right" onClick={(e) => e.stopPropagation()}>
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    className="text-blue-500 hover:text-blue-700"
                    onClick={(e) => {
                      e.stopPropagation();
                      onProjectClick(project._id);
                    }}
                  >
                    <Eye className="h-4 w-4" />
                  </Button>
                  {canEdit && (
                    <>
                      <Button 
                        variant="ghost" 
                        size="sm" 
                        className="text-yellow-500 hover:text-yellow-700"
                        onClick={(e) => {
                          e.stopPropagation();
                          onEdit(project);
                        }}
                      >
                        <Pencil className="h-4 w-4" />
                      </Button>
                      <Button 
                        variant="ghost" 
                        size="sm" 
                        className="text-red-500 hover:text-red-700 ml-2"
                        onClick={(e) => {
                          e.stopPropagation();
                          onDelete(project._id);
                        }}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </>
                  )}
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
  );
};













// frontend/app/component/stages/stage-management.tsx
"use client";
import React, { useState, useMemo } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader } from "@/components/loader";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert, Trash2, Pencil, Plus } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useStages } from "@/hooks/use-stages";
import { useAuth } from "@/provider/auth-context";
import { stageSchema, type StageEntry } from "@/lib/schema";
import { z } from "zod";
import { SearchBar } from "@/components/ui/search-bar";

const StageManagement = () => {
  const { user } = useAuth();
  const { stages, isLoading, error, addStage, updateStage, deleteStage } = useStages();
  const [showModal, setShowModal] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [stageToDelete, setStageToDelete] = useState<string | null>(null);
  const [currentStage, setCurrentStage] = useState<StageEntry | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');
  
  // Determine if user can edit stages
  const canEditStages = user?.role === "manager";
  
  // Create form instance
  const form = useForm<z.infer<typeof stageSchema>>({
    resolver: zodResolver(stageSchema),
    defaultValues: {
      stage_name: "",
      description: "",
    },
  });
  
  // Filter stages based on search term
  const filteredStages = useMemo(() => {
    if (!searchTerm) return stages;
    
    const term = searchTerm.toLowerCase();
    return stages.filter(stage => 
      stage.stage_name.toLowerCase().includes(term) ||
      (stage.description && stage.description.toLowerCase().includes(term))
    );
  }, [stages, searchTerm]);
  
  const handleAddClick = () => {
    // Only managers can create stages
    if (!canEditStages) {
      alert("Only managers can create stages");
      return;
    }
    
    setCurrentStage(null);
    form.reset({ stage_name: "", description: "" }); // Reset form
    setShowModal(true);
  };
  
  const handleEditClick = (stage: StageEntry) => {
    // Only managers can edit stages
    if (!canEditStages) {
      alert("Only managers can edit stages");
      return;
    }
    
    setCurrentStage(stage);
    form.reset({ 
      stage_name: stage.stage_name, 
      description: stage.description || ""
    }); // Reset form with stage data
    setShowModal(true);
  };
  
  const handleDeleteClick = (_id: string) => {
    // Only managers can delete stages
    if (!canEditStages) {
      alert("Only managers can delete stages");
      return;
    }
    
    setStageToDelete(_id);
    setShowDeleteDialog(true);
  };
  
  const handleConfirmDelete = async () => {
    if (stageToDelete) {
      await deleteStage(stageToDelete);
    }
    setShowDeleteDialog(false);
    setStageToDelete(null);
  };
  
  const handleSubmit = async (values: z.infer<typeof stageSchema>) => {
    if (currentStage) {
      // Editing an existing stage
      await updateStage(currentStage._id, values);
    } else {
      // Adding a new stage
      await addStage(values);
    }
    setShowModal(false);
  };
  
  return (
    <div className="container mx-auto p-4 pt-0">
      {/* Header with no bottom margin */}
      <div className="flex items-center justify-between mb-0">
        <h3 className="text-xl font-bold">
          {canEditStages ? "Stage Management" : "Stages"}
        </h3>
        {canEditStages && (
          <Button onClick={handleAddClick} className="flex items-center gap-1 text-sm py-1 h-8">
            <Plus className="h-3 w-3" /> Add Stage
          </Button>
        )}
      </div>
      
      {/* Search Input using the reusable SearchBar component */}
      <div className="mb-4 p-3 bg-gray-50 rounded-lg">
        <SearchBar
          placeholder="Search stages by name or description..."
          value={searchTerm}
          onChange={setSearchTerm}
        />
      </div>
      
      {error && (
        <Alert variant="destructive" className="mb-2">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {/* Scrollable table container */}
      <div className="overflow-y-auto max-h-[calc(100vh-200px)]">
        {isLoading ? (
          <Loader />
        ) : (
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[50px]">#</TableHead>
                  <TableHead className="w-[200px]">Stage Name</TableHead>
                  <TableHead className="w-[300px]">Description</TableHead>
                  {canEditStages && <TableHead className="w-[100px] text-right">Actions</TableHead>}
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredStages.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={canEditStages ? 4 : 3} className="text-center h-32">
                      {stages.length === 0 ? "No stages found." : "No stages match your search."}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredStages.map((stage, index) => (
                    <TableRow key={stage._id}>
                      <TableCell>{index + 1}</TableCell>
                      <TableCell className="whitespace-normal break-words" title={stage.stage_name}>
                        {stage.stage_name}
                      </TableCell>
                      <TableCell className="whitespace-normal break-words" title={stage.description}>
                        {stage.description}
                      </TableCell>
                      {canEditStages && (
                        <TableCell className="text-right">
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-yellow-500 hover:text-yellow-700"
                            onClick={() => handleEditClick(stage)}
                          >
                            <Pencil className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="text-red-500 hover:text-red-700 ml-2"
                            onClick={() => handleDeleteClick(stage._id)}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TableCell>
                      )}
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        )}
      </div>
      
      {/* Modal for Adding & Editing Stages - Only for Managers */}
      {canEditStages && (
        <>
          <Dialog open={showModal} onOpenChange={setShowModal}>
            <DialogContent className="sm:max-w-[425px]">
              <DialogHeader>
                <DialogTitle>
                  {currentStage ? "Edit Stage" : "Add Stage"}
                </DialogTitle>
                <DialogDescription>
                  {currentStage 
                    ? "Update the stage details below." 
                    : "Fill in the details to create a new stage."
                  }
                </DialogDescription>
              </DialogHeader>
              <Form {...form}>
                <form onSubmit={form.handleSubmit(handleSubmit)}>
                  <FormField
                    control={form.control}
                    name="stage_name"
                    render={({ field }) => (
                      <FormItem className="mb-4">
                        <FormLabel>Stage Name</FormLabel>
                        <FormControl>
                          <Input placeholder="Enter Stage Name" {...field} />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    control={form.control}
                    name="description"
                    render={({ field }) => (
                      <FormItem className="mb-4">
                        <FormLabel>Description</FormLabel>
                        <FormControl>
                          <Textarea 
                            placeholder="Enter Stage Description" 
                            className="min-h-[100px]"
                            {...field} 
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <DialogFooter className="mt-4">
                    <Button type="submit">
                      {currentStage ? "Update Stage" : "Add Stage"}
                    </Button>
                  </DialogFooter>
                </form>
              </Form>
            </DialogContent>
          </Dialog>
          
          {/* Custom Confirmation Dialog for Deleting */}
          <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                <AlertDialogDescription>
                  This action cannot be undone. This will permanently delete the stage.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        </>
      )}
    </div>
  );
};

export default StageManagement;








\\frontend/app/components/back-button.tsx

import { useNavigate } from "react-router";
import { Button } from "./ui/button";

export const BackButton = () => {
  const navigate = useNavigate();

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={() => navigate(-1)}
      className="p-4 mr-4"
    >
      ← Back
    </Button>
  );
};







// frontend/app/components/loader.tsx
import { Loader2 } from "lucide-react";

interface LoaderProps {
  className?: string;
}

export const Loader = ({ className }: LoaderProps) => {
  return (
    <div className="flex justify-center items-center">
      <Loader2 className={`h-8 w-8 animate-spin ${className || ""}`} />
    </div>
  );
};

// Optional: Default export for backward compatibility
export default Loader;




\\frontend/app/components/no-data-found.tsx
import { CirclePlus, LayoutGrid } from "lucide-react";
import { Button } from "./ui/button";

interface NoDataFoundProps {
  title: string;
  description: string;
  buttonText: string;
  buttonAction: () => void;
}

export const NoDataFound = ({
  title,
  description,
  buttonText,
  buttonAction,
}: NoDataFoundProps) => {
  return (
    <div className="col-span-full text-center py-12 2xl:py-24 bg-muted/40 rounded-lg">
      <LayoutGrid className="size-12 mx-auto text-muted-foreground" />
      <h3 className="mt-4 text-lg font-semibold">{title}</h3>

      <p className="mt-2 text-sm text-muted-foreground max-w-sm mx-auto">
        {description}
      </p>
      <Button onClick={buttonAction} className="mt-4">
        <CirclePlus className="size-4 mr-2" />
        {buttonText}
      </Button>
    </div>
  );
};









// frontend/app/hooks/use-auth.ts
import { postData } from "@/lib/fetch-util";
import type { SignupFormData } from "@/routes/auth/sign-up";
import { useMutation } from "@tanstack/react-query";
import type { User } from "@/types";

export const useSignUpMutation = () => {
  return useMutation<{ token: string; user: User }, Error, SignupFormData>({
    mutationFn: (data: SignupFormData) => postData<{ token: string; user: User }>("/auth/register", data),
  });
};

export const useVerifyEmailMutation = () => {
  return useMutation({
    mutationFn: (data: { token: string }) =>
      postData("/auth/verify-email", data),
  });
};

export const useLoginMutation = () => {
  return useMutation<{ token: string; user: User }, Error, { email: string; password: string }>({
    mutationFn: (data: { email: string; password: string }) => 
      postData<{ token: string; user: User }>("/auth/login", data),
  });
};

export const useForgotPasswordMutation = () => {
  return useMutation({
    mutationFn: (data: { email: string }) =>
      postData("/auth/reset-password-request", data),
  });
};

export const useResetPasswordMutation = () => {
  return useMutation({
    mutationFn: (data: {
      token: string;
      newPassword: string;
      confirmPassword: string;
    }) => postData("/auth/reset-password", data),
  });
};





\\frontend/app/hooks/use-emails.ts
import { useState, useEffect } from "react";
import { type EmailEntry, emailSchema } from "@/lib/schema"; // Import schema and type
import { z } from "zod";

const API_BASE_URL = import.meta.env.VITE_API_URL ||"http://localhost:5000/api-v1";

// A custom hook to manage all email-related data and logic
export const useEmails = () => {
  const [emails, setEmails] = useState<EmailEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Function to fetch all emails from the backend
  const fetchEmails = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const res = await fetch(`${API_BASE_URL}/emails/all-emails`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        throw new Error("Failed to fetch emails.");
      }
      const data = await res.json();
      setEmails(data);
    } catch (err) {
      console.error("Error fetching emails:", err);
      setError("Failed to load emails. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };
  
  // Function to add a new email
  const addEmail = async (newEmail: z.infer<typeof emailSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/emails/add-email`, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(newEmail),
      });
      if (!res.ok) {
        throw new Error("Failed to add email.");
      }
      // Re-fetch the email list to update the UI
      fetchEmails();
    } catch (err) {
      console.error("Error adding email:", err);
      setError("Failed to add email. Please try again.");
    }
  };
  
  // Function to update an existing email
  const updateEmail = async (id: string, updatedEmail: z.infer<typeof emailSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/emails/update-email/${id}`, {
        method: "PUT",
        headers: { 
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(updatedEmail),
      });
      if (!res.ok) {
        throw new Error("Failed to update email.");
      }
      fetchEmails();
    } catch (err) {
      console.error("Error updating email:", err);
      setError("Failed to update email. Please try again.");
    }
  };
  
  // Function to delete an email
  const deleteEmail = async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/emails/delete-email/${id}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        throw new Error("Failed to delete email.");
      }
      fetchEmails();
    } catch (err) {
      console.error("Error deleting email:", err);
      setError("Failed to delete email. Please try again.");
    }
  };
  
  // Fetch emails on initial render
  useEffect(() => {
    fetchEmails();
  }, []);
  
  return {
    emails,
    isLoading,
    error,
    fetchEmails,
    addEmail,
    updateEmail,
    deleteEmail,
  };
};












// frontend/app/hooks/use-projects.ts
import { useState, useEffect, useCallback } from "react";
import { type ProjectEntry, projectSchema } from "@/lib/schema";
import { z } from "zod";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

export const useProjects = () => {
  const [projects, setProjects] = useState<ProjectEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Memoize fetchProjects to prevent unnecessary re-renders
  const fetchProjects = useCallback(async (filters?: { year?: string; month?: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      // Build query string from filters
      const queryParams = new URLSearchParams();
      
      // Only add year filter if it's not "all" and not empty
      if (filters?.year && filters.year !== 'all') {
        queryParams.append('year', filters.year);
      }
      
      if (filters?.month) {
        queryParams.append('month', filters.month);
      }
      
      const queryString = queryParams.toString();
      const url = `${API_BASE_URL}/projects/all-projects${queryString ? `?${queryString}` : ''}`;
      
      console.log("Fetching projects from:", url); // Debug log
      
      const res = await fetch(url, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Failed to fetch projects.");
      }
      const data = await res.json();
      console.log("Projects data received:", data); // Debug log
      setProjects(data);
    } catch (err) {
      console.error("Error fetching projects:", err);
      setError(err instanceof Error ? err.message : "Failed to load projects. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // New function to fetch available years
  const fetchProjectYears = useCallback(async () => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project-years`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        throw new Error("Failed to fetch project years.");
      }
      const data = await res.json();
      return data;
    } catch (err) {
      console.error("Error fetching project years:", err);
      setError(err instanceof Error ? err.message : "Failed to fetch project years.");
      return [];
    }
  }, []);
  
  const createProject = useCallback(async (newProject: z.infer<typeof projectSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(newProject),
      });
      if (!res.ok) {
        throw new Error("Failed to create project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error creating project:", err);
      setError("Failed to create project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Update to handle partial updates
  const updateProject = useCallback(async (id: string, updatedProject: Partial<z.infer<typeof projectSchema>>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(updatedProject),
      });
      if (!res.ok) {
        throw new Error("Failed to update project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error updating project:", err);
      setError("Failed to update project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Add function to update project status
  const updateProjectStatus = useCallback(async (id: string, status: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${id}/status`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({ status }),
      });
      if (!res.ok) {
        throw new Error("Failed to update project status.");
      }
      await fetchProjects();
      return true;
    } catch (err) {
      console.error("Error updating project status:", err);
      setError("Failed to update project status. Please try again.");
      return false;
    }
  }, [fetchProjects]);
  
  const deleteProject = useCallback(async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/delete-project/${id}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        throw new Error("Failed to delete project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error deleting project:", err);
      setError("Failed to delete project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Initial fetch on mount
  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);
  
  return {
    projects,
    isLoading,
    error,
    createProject,
    updateProject,
    updateProjectStatus,  // Add this to the return object
    deleteProject,
    fetchProjects,
    fetchProjectYears,
    refetch: fetchProjects
  };
};













\\frontend/app/hooks/use-stages.ts
import { useState, useEffect } from "react";
import { type StageEntry, stageSchema } from "@/lib/schema";
import { z } from "zod";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

export const useStages = (projectId?: string) => {
  const [stages, setStages] = useState<StageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchStages = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const url = projectId 
        ? `${API_BASE_URL}/stages/all-stages?projectId=${projectId}`
        : `${API_BASE_URL}/stages/all-stages`;
      
      const res = await fetch(url, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (!res.ok) {
        throw new Error("Failed to fetch stages.");
      }
      
      const data = await res.json();
      setStages(data);
    } catch (err) {
      console.error("Error fetching stages:", err);
      setError("Failed to load stages. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const addStage = async (newStage: z.infer<typeof stageSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/add-stage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(newStage),
      });
      
      if (!res.ok) {
        throw new Error("Failed to create stage.");
      }
      
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error creating stage:", err);
      setError("Failed to create stage. Please try again.");
      return false;
    }
  };

  const updateStage = async (id: string, updatedStage: z.infer<typeof stageSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/update-stage/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(updatedStage),
      });
      
      if (!res.ok) {
        throw new Error("Failed to update stage.");
      }
      
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error updating stage:", err);
      setError("Failed to update stage. Please try again.");
      return false;
    }
  };

  const deleteStage = async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/delete-stage/${id}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (!res.ok) {
        throw new Error("Failed to delete stage.");
      }
      
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error deleting stage:", err);
      setError("Failed to delete stage. Please try again.");
      return false;
    }
  };

  const deleteCustomStageFromProject = async (stageId: string, projectId: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/delete-custom-stage-from-project`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({ stageId, projectId }),
      });
      
      if (!res.ok) {
        throw new Error("Failed to delete custom stage.");
      }
      
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error deleting custom stage:", err);
      setError("Failed to delete custom stage. Please try again.");
      return false;
    }
  };

  useEffect(() => {
    fetchStages();
  }, [projectId]);

  return {
    stages,
    isLoading,
    error,
    addStage,
    updateStage,
    deleteStage,
    deleteCustomStageFromProject,
    refetch: fetchStages
  };
};












\\frontend/app/hooks/use-user.ts

import { fetchData, updateData } from "@/lib/fetch-util";
import type {
  ChangePasswordFormData,
  ProfileFormData,
} from "@/routes/user/profile";
import { useMutation, useQuery, type QueryKey } from "@tanstack/react-query";

const queryKey: QueryKey = ["user"];

export const useUserProfileQuery = () => {
  return useQuery({
    queryKey,
    queryFn: () => fetchData("/users/profile"),
  });
};

export const useChangePassword = () => {
  return useMutation({
    mutationFn: (data: ChangePasswordFormData) =>
      updateData("/users/change-password", data),
  });
};

export const useUpdateUserProfile = () => {
  return useMutation({
    mutationFn: (data: ProfileFormData) => updateData("/users/profile", data),
  });
};











// frontend/app/hooks/useCustomProjectStages.ts
import { useState, useEffect } from "react";
import { type ProjectStageEntry } from "@/lib/schema";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

export const useCustomProjectStages = (projectId: string | null) => {
  const [customStages, setCustomStages] = useState<ProjectStageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchCustomStages = async () => {
    if (!projectId) return;
    
    setIsLoading(true);
    setError(null);
    try {
      const res = await fetch(`${API_BASE_URL}/custom-project-stages/project/${projectId}`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!res.ok) {
        throw new Error("Failed to fetch custom stages.");
      }
      const data = await res.json();
      setCustomStages(data.customStages || []);
    } catch (err) {
      console.error("Error fetching custom stages:", err);
      setError("Failed to load custom stages. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const createCustomStage = async (customStageData: {
    stage_name: string;
    description?: string;
    project: string;
  }) => {
    try {
      const res = await fetch(`${API_BASE_URL}/custom-project-stages`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify(customStageData),
      });
      if (!res.ok) {
        throw new Error("Failed to create custom stage.");
      }
      await fetchCustomStages();
      return true;
    } catch (err) {
      console.error("Error creating custom stage:", err);
      setError("Failed to create custom stage. Please try again.");
      return false;
    }
  };

  useEffect(() => {
    if (projectId) {
      fetchCustomStages();
    }
  }, [projectId]);

  return {
    customStages,
    isLoading,
    error,
    createCustomStage,
    refetch: fetchCustomStages
  };
};















\\frontend/app/hooks/use-Dashboard.ts
import { useState, useEffect, useCallback } from "react";
import { useProjects } from "./use-projects";
import { useStages } from "./use-stages";
import { useAuth } from "@/provider/auth-context";
import { type ProjectEntry, type StageEntry, type ProjectStageEntry } from "@/lib/schema";
import { format, startOfYear, endOfYear, startOfMonth, endOfMonth, isWithinInterval, getYear, getMonth } from "date-fns";

export interface TimePeriod {
  type: 'year' | 'month';
  value: string;
}

export const useDashboard = (timePeriod?: TimePeriod, projects?: ProjectEntry[]) => {
  const { user } = useAuth();
  const { isLoading: projectsLoading, error: projectsError } = useProjects();
  const { stages: allStages, isLoading: stagesLoading, error: stagesError } = useStages();
  
  const [dashboardData, setDashboardData] = useState<{
    totalProjects: number;
    ongoingProjects: number;
    completedProjects: number;
    pendingProjects: number;
    totalStages: number;
    ongoingStages: number;
    completedStages: number;
    projectStatusData: any[];
    recentProjects: ProjectEntry[];
    upcomingStages: ProjectStageEntry[];
  }>({
    totalProjects: 0,
    ongoingProjects: 0,
    completedProjects: 0,
    pendingProjects: 0,
    totalStages: 0,
    ongoingStages: 0,
    completedStages: 0,
    projectStatusData: [],
    recentProjects: [],
    upcomingStages: []
  });
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Process data when projects or stages change
  const processData = useCallback(() => {
    try {
      // Use the projects passed as parameter if available, otherwise use the ones from the hook
      const projectsToUse = projects || [];
      
      // Calculate statistics
      const totalProjects = projectsToUse.length;
      const ongoingProjects = projectsToUse.filter(p => p.status === 'Ongoing').length;
      const completedProjects = projectsToUse.filter(p => p.status === 'Completed').length;
      const pendingProjects = projectsToUse.filter(p => p.status === 'Pending').length;
      
      // Get all project stages from all projects
      const allProjectStages: ProjectStageEntry[] = [];
      projectsToUse.forEach(project => {
        if (project.stages && Array.isArray(project.stages)) {
          project.stages.forEach(stage => {
            // Ensure stage has the required properties
            if (stage && stage._id && stage.status) {
              allProjectStages.push(stage as ProjectStageEntry);
            }
          });
        }
      });
      
      const totalStages = allProjectStages.length;
      const ongoingStages = allProjectStages.filter(s => s.status === 'Ongoing').length;
      const completedStages = allProjectStages.filter(s => s.status === 'Completed').length;
      
      // Project status data for pie chart
      const statusCounts = {
        'Pending': pendingProjects,
        'Ongoing': ongoingProjects,
        'Completed': completedProjects,
        'Archived': projectsToUse.filter(p => p.status === 'Archived').length
      };
      
      const projectStatusData = [
        { name: 'Pending', value: statusCounts.Pending, color: '#FFBB28' },
        { name: 'Ongoing', value: statusCounts.Ongoing, color: '#0088FE' },
        { name: 'Completed', value: statusCounts.Completed, color: '#00C49F' },
        { name: 'Archived', value: statusCounts.Archived, color: '#FF8042' }
      ];
      
      // Recent projects (last 5)
      const sortedProjects = [...projectsToUse]
        .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
        .slice(0, 5);
      
      // Upcoming stages (ongoing stages sorted by start date)
      const sortedStages = [...allProjectStages]
        .filter(stage => stage.status === 'Ongoing')
        .sort((a, b) => {
          const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
          const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
          return dateA - dateB;
        })
        .slice(0, 5);
      
      setDashboardData({
        totalProjects,
        ongoingProjects,
        completedProjects,
        pendingProjects,
        totalStages,
        ongoingStages,
        completedStages,
        projectStatusData,
        recentProjects: sortedProjects,
        upcomingStages: sortedStages
      });
      
      setIsLoading(false);
    } catch (err) {
      console.error("Error processing dashboard data:", err);
      setError("Failed to process dashboard data");
      setIsLoading(false);
    }
  }, [projects]);
  
  // Process data when projects or stages loading state changes
  useEffect(() => {
    if (!projectsLoading && !stagesLoading) {
      processData();
    }
  }, [projectsLoading, stagesLoading, processData]);
  
  // Combine errors
  useEffect(() => {
    if (projectsError || stagesError) {
      setError(projectsError || stagesError || "An error occurred");
    }
  }, [projectsError, stagesError]);
  
  return {
    ...dashboardData,
    isLoading: isLoading || projectsLoading || stagesLoading,
    error,
    refetch: processData
  };
};
















\\frontend/app/hooks/useProjectDetail.ts
import { useState, useEffect } from "react";
import { type ProjectEntry, type ProjectStageEntry, type StageEntry, type StageConnectionEntry } from "@/lib/schema";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

export const useProjectDetail = (projectId: string | null) => {
  const [project, setProject] = useState<ProjectEntry | null>(null);
  const [stages, setStages] = useState<ProjectStageEntry[]>([]);
  const [connections, setConnections] = useState<StageConnectionEntry[]>([]);
  const [availableStages, setAvailableStages] = useState<StageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchProjectDetail = async () => {
    if (!projectId) return;
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Fetch project details
      const projectRes = await fetch(`${API_BASE_URL}/projects/${projectId}`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (!projectRes.ok) {
        if (projectRes.status === 403) {
          throw new Error("Access denied. You don't have permission to view this project.");
        }
        throw new Error("Failed to fetch project");
      }
      
      const projectData = await projectRes.json();
      setProject(projectData);
      
      // Fetch project stages and sort by date
      if (projectData.stages) {
        // Sort stages by date (oldest first)
        const sortedStages = [...projectData.stages].sort((a, b) => {
          const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
          const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
          return dateA - dateB;
        });
        setStages(sortedStages);
      }
      
      // Fetch stage connections
      const connectionsRes = await fetch(`${API_BASE_URL}/projects/${projectId}/connections`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (connectionsRes.ok) {
        const connectionsData = await connectionsRes.json();
        setConnections(connectionsData);
      }
      
      // Fetch all available stages
      const stagesRes = await fetch(`${API_BASE_URL}/stages/all-stages`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (stagesRes.ok) {
        const allStages = await stagesRes.json();
        
        // Filter out stages already added to the project
        const addedStageIds = projectData.stages?.map((s: ProjectStageEntry) => s.stage._id) || [];
        const filteredStages = allStages.filter((stage: StageEntry) => 
          !addedStageIds.includes(stage._id)
        );
        
        setAvailableStages(filteredStages);
      }
    } catch (err) {
      console.error("Error fetching project detail:", err);
      setError(err instanceof Error ? err.message : "Failed to load project details. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };
  
  const addStageToProject = async (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages`, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          stageId,
          status,
          start_date: status === 'Ongoing' ? startDate : undefined,
          completion_date: status === 'Completed' ? completionDate : undefined
        }),
      });
      
      if (!res.ok) {
        if (res.status === 403) {
          throw new Error("Access denied. You don't have permission to modify this project.");
        }
        throw new Error("Failed to add stage to project");
      }
      
      // Update project status based on the first stage added
      const stageData = await res.json();
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error adding stage to project:", err);
      setError(err instanceof Error ? err.message : "Failed to add stage to project. Please try again.");
      return false;
    }
  };
  
  const updateProjectStage = async (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages/${stageId}`, {
        method: "PUT",
        headers: { 
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          status,
          start_date: status === 'Ongoing' ? startDate : undefined,
          completion_date: status === 'Completed' ? completionDate : undefined
        }),
      });
      
      if (!res.ok) {
        if (res.status === 403) {
          throw new Error("Access denied. You don't have permission to modify this project.");
        }
        throw new Error("Failed to update project stage");
      }
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error updating project stage:", err);
      setError(err instanceof Error ? err.message : "Failed to update project stage. Please try again.");
      return false;
    }
  };
  
  const deleteProjectStage = async (stageId: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages/${stageId}`, {
        method: "DELETE",
        headers: {
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      
      if (!res.ok) {
        if (res.status === 403) {
          throw new Error("Access denied. You don't have permission to modify this project.");
        }
        throw new Error("Failed to delete project stage");
      }
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error deleting project stage:", err);
      setError(err instanceof Error ? err.message : "Failed to delete project stage. Please try again.");
      return false;
    }
  };
  
  const createStageConnection = async (fromStageId: string, toStageId: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/connections`, {
        method: "POST",
        headers: { 
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          fromStageId,
          toStageId
        }),
      });
      
      if (!res.ok) {
        if (res.status === 403) {
          throw new Error("Access denied. You don't have permission to modify this project.");
        }
        throw new Error("Failed to create stage connection");
      }
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error creating stage connection:", err);
      setError(err instanceof Error ? err.message : "Failed to create stage connection. Please try again.");
      return false;
    }
  };
  
  useEffect(() => {
    fetchProjectDetail();
  }, [projectId]);
  
  return {
    project,
    stages,
    connections,
    availableStages,
    isLoading,
    error,
    addStageToProject,
    updateProjectStage,
    deleteProjectStage,
    createStageConnection,
    refetch: fetchProjectDetail
  };
};












\\frontend/app/hooks/useProjectStages.ts
import { useState, useEffect } from "react";
import { type ProjectStageEntry } from "@/lib/schema";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

export const useProjectStages = () => {
  const [projectStages, setProjectStages] = useState<ProjectStageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchProjectStages = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // First, fetch all projects
      const projectsRes = await fetch(`${API_BASE_URL}/projects/all-projects`);
      if (!projectsRes.ok) throw new Error("Failed to fetch projects");
      const projects = await projectsRes.json();
      
      // Then, for each project, fetch its stages
      const allProjectStages: ProjectStageEntry[] = [];
      
      for (const project of projects) {
        try {
          const projectRes = await fetch(`${API_BASE_URL}/projects/${project._id}`);
          if (projectRes.ok) {
            const projectData = await projectRes.json();
            if (projectData.stages && Array.isArray(projectData.stages)) {
              allProjectStages.push(...projectData.stages);
            }
          }
        } catch (err) {
          console.error(`Error fetching stages for project ${project._id}:`, err);
          // Continue with other projects even if one fails
        }
      }
      
      setProjectStages(allProjectStages);
    } catch (err) {
      console.error("Error fetching project stages:", err);
      setError("Failed to load project stages. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchProjectStages();
  }, []);

  return {
    projectStages,
    isLoading,
    error,
    refetch: fetchProjectStages
  };
};










// frontend/app/hooks/useUserManagement.ts
import { useMutation, useQuery } from "@tanstack/react-query";
import { fetchData, postData, updateData } from "@/lib/fetch-util";
import type { User } from "@/types";

export const useReferredUsers = () => {
  return useQuery<User[]>({
    queryKey: ["referred-users"],
    queryFn: () => fetchData("/users/referred-users"),
  });
};

export const useToggleUserStatus = () => {
  return useMutation({
    mutationFn: ({ userId }: { userId: string }) =>
      updateData(`/users/users/${userId}/toggle-status`, {}),
  });
};

export const useGetReferralLink = () => {
  return useQuery<{ referralLink: string }>({
    queryKey: ["referral-link"],
    queryFn: () => fetchData("/users/referral-link"),
  });
};











// frontend/app/lib/fetch-util.ts
import axios from "axios";
import type { User } from "@/types"; // Import User type directly

const BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

const api = axios.create({
  baseURL: BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Add a global handler for 401 errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Dispatch a custom event to trigger logout in AuthProvider
      window.dispatchEvent(new Event("force-logout"));
    }
    return Promise.reject(error);
  }
);

const postData = async <T>(url: string, data: unknown): Promise<T> => {
  const response = await api.post(url, data);
  return response.data;
};

const updateData = async <T>(url: string, data: unknown): Promise<T> => {
  const response = await api.put(url, data);
  return response.data;
};

const fetchData = async <T>(url: string): Promise<T> => {
  const response = await api.get(url);
  return response.data;
};

const deleteData = async <T>(url: string): Promise<T> => {
  const response = await api.delete(url);
  return response.data;
};

export { postData, fetchData, updateData, deleteData };










// frontend/app/component/lib/index.ts
import type { ProjectStatus } from "@/types";

export const publicRoutes = [
  "/",
  "/sign-in",
  "/sign-up",
  "/verify-email",
  "/reset-password",
  "/forgot-password",
  "*",
];











\\frontend/app/lib/schema.ts

import { z } from "zod";

export const signInSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(6, "Password is required"),
});

export const signUpSchema = z
  .object({
    email: z.string().email("Invalid email address"),
    password: z.string().min(8, "Password must be 8 characters"),
    name: z.string().min(3, "Name must be at least 3 characters"),
    confirmPassword: z.string().min(8, "Password must be 8 characters"),
    ref: z.string().optional(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match",
  });

export const resetPasswordSchema = z
  .object({
    newPassword: z.string().min(8, "Password must be 8 characters"),
    confirmPassword: z.string().min(8, "Password must be 8 characters"),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match",
  });

export const forgotPasswordSchema = z.object({
  email: z.string().email("Invalid email address"),
});

// Project schema
export const projectSchema = z.object({
  project_name: z.string().min(1, { message: "Project name is required" }),
  description: z.string().optional(),
  status: z.enum(['Pending', 'Ongoing', 'Completed', 'Archived']).optional(),
  created_at: z.string().min(1, { message: "Created at date is required" }),
});

export type ProjectEntry = z.infer<typeof projectSchema> & {
  _id: string;
  stages?: ProjectStageEntry[];
  owner: {
    _id: string;
    name: string;
    email: string;
  };
};

// Stage schema
export const stageSchema = z.object({
  stage_name: z.string().min(1, { message: "Stage name is required" }),
  description: z.string().optional(),
  isCustom: z.boolean().optional(),
  projectId: z.string().optional(),
});

export type StageEntry = z.infer<typeof stageSchema> & {
  _id: string;
  owner: {
    _id: string;
    name: string;
    email: string;
  };
  isCustom: boolean;
  projectSpecific: string | null;
};

// Project Stage schema
export const projectStageSchema = z.object({
  status: z.enum(['Ongoing', 'Completed']),
  start_date: z.string().optional(),
  completion_date: z.string().optional(),
  order: z.number(),
});

export type ProjectStageEntry = z.infer<typeof projectStageSchema> & {
  _id: string;
  project: string;
  stage: StageEntry;
  connections?: StageConnectionEntry[];
};

// Stage Connection schema
export const stageConnectionSchema = z.object({
  from_stage: z.string(),
  to_stage: z.string(),
});

export type StageConnectionEntry = z.infer<typeof stageConnectionSchema> & {
  _id: string;
  project: string;
  from_stage: ProjectStageEntry;
  to_stage: ProjectStageEntry;
};

// Email schema
export const emailSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  email: z.string().email({ message: "Invalid email address" }),
});

export type EmailEntry = z.infer<typeof emailSchema> & {
  _id: string;
  owner: {
    _id: string;
    name: string;
    email: string;
  };
};







\\frontend/app/lib/utils.ts

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}











\\frontend/app/provider/auth-context.tsx

import React, { createContext, useContext, useEffect, useState } from "react";
import { useNavigate } from "react-router";
import { Loader2 } from "lucide-react";
import type { User } from "@/types";

interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (data: { token: string; user: User }) => void;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

interface AuthProviderProps {
  children: React.ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const navigate = useNavigate();

  useEffect(() => {
    const storedToken = localStorage.getItem("token");
    const storedUser = localStorage.getItem("user");

    if (storedToken && storedUser) {
      setToken(storedToken);
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);

  const login = (data: { token: string; user: User }) => {
    setToken(data.token);
    setUser(data.user);
    localStorage.setItem("token", data.token);
    localStorage.setItem("user", JSON.stringify(data.user));
  };

  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem("token");
    localStorage.removeItem("user");
    navigate("/sign-in");
  };

  // Listen for force logout event
  useEffect(() => {
    const handleForceLogout = () => {
      logout();
    };

    window.addEventListener("force-logout", handleForceLogout);
    return () => {
      window.removeEventListener("force-logout", handleForceLogout);
    };
  }, [logout]);

  const value: AuthContextType = {
    user,
    token,
    isAuthenticated: !!token && !!user,
    isLoading,
    login,
    logout,
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <Loader2 className="h-8 w-8 animate-spin" />
      </div>
    );
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};











\\frontend/app/provider/react-query-provider.tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import React from "react";
import { Toaster } from "sonner";
import { AuthProvider } from "./auth-context";

export const queryClient = new QueryClient();

const ReactQueryProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        {children}
        <Toaster position="top-center" richColors />
      </AuthProvider>
    </QueryClientProvider>
  );
};

export default ReactQueryProvider;











\\frontend/app/routes/auth/auth-layout.tsx

import { useAuth } from "@/provider/auth-context";
import React from "react";
import { Navigate, Outlet } from "react-router";

const AuthLayout = () => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isAuthenticated) {
    return <Navigate to="/dashboard" />;
  }

  return <Outlet />;
};

export default AuthLayout;







\\frontend/app/routes/auth/reset-password.tsx
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useForgotPasswordMutation } from "@/hooks/use-auth";
import { forgotPasswordSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { ArrowLeft, CheckCircle, Loader2 } from "lucide-react";
import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { Link } from "react-router";
import { toast } from "sonner";
import type { z } from "zod";

type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>;

const ForgotPassword = () => {
  const [isSuccess, setIsSuccess] = useState(false);

  const { mutate: forgotPassword, isPending } = useForgotPasswordMutation();

  const form = useForm<ForgotPasswordFormData>({
    resolver: zodResolver(forgotPasswordSchema),
    defaultValues: {
      email: "",
    },
  });

  const onSubmit = (data: ForgotPasswordFormData) => {
    forgotPassword(data, {
      onSuccess: () => {
        setIsSuccess(true);
      },
      onError: (error: any) => {
        const errorMessage = error.response?.data?.message;
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="w-full max-w-md space-y-6">
        <div className="flex flex-col items-center justify-center space-y-2">
          <h1 className="text-2xl font-bold">Forgot Password</h1>
          <p className="text-muted-foreground">
            Enter your email to reset your password
          </p>
        </div>

        <Card>
          <CardHeader>
            <Link to="/sign-in" className="flex items-center gap-2">
              <ArrowLeft className="w-4 h-4" />
              <span>Back to sign in</span>
            </Link>
          </CardHeader>

          <CardContent>
            {isSuccess ? (
              <div className="flex flex-col items-center justify-center">
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h1 className="text-2xl font-bold">
                  Password reset email sent
                </h1>
                <p className="text-muted-foreground">
                  Check your email for a link to reset your password
                </p>
              </div>
            ) : (
              <>
                <Form {...form}>
                  <form
                    onSubmit={form.handleSubmit(onSubmit)}
                    className="space-y-4"
                  >
                    <FormField
                      name="email"
                      control={form.control}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Email Address</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="Enter your email" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <Button
                      type="submit"
                      className="w-full"
                      disabled={isPending}
                    >
                      {isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin" />
                      ) : (
                        "Reset Password"
                      )}
                    </Button>
                  </form>
                </Form>
              </>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ForgotPassword;









\\frontend/app/routes/auth/reset-password.tsx
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useResetPasswordMutation } from "@/hooks/use-auth";
import { resetPasswordSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { ArrowBigDown, ArrowLeft, CheckCircle, Loader2 } from "lucide-react";
import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { Link, useSearchParams } from "react-router";
import { toast } from "sonner";
import { z } from "zod";

type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>;

const ResetPassword = () => {
  const [searchParams] = useSearchParams();

  const token = searchParams.get("token");

  const [isSuccess, setIsSuccess] = useState(false);
  const { mutate: resetPassword, isPending } = useResetPasswordMutation();

  const form = useForm<ResetPasswordFormData>({
    resolver: zodResolver(resetPasswordSchema),
    defaultValues: {
      newPassword: "",
      confirmPassword: "",
    },
  });

  const onSubmit = (values: ResetPasswordFormData) => {
    if (!token) {
      toast.error("Invalid token");
      return;
    }

    resetPassword(
      { ...values, token: token as string },
      {
        onSuccess: () => {
          setIsSuccess(true);
        },
        onError: (error: any) => {
          const errorMessage = error.response?.data?.message;
          toast.error(errorMessage);
          console.log(error);
        },
      }
    );
  };

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="w-full max-w-md space-y-6">
        <div className="flex flex-col items-center justify-center space-y-2">
          <h1 className="text-2xl font-bold">Reset Password</h1>
          <p className="text-muted-foreground">Enter your password below</p>
        </div>

        <Card>
          <CardHeader>
            <Link to="/sign-in" className="flex items-center gap-2">
              <ArrowLeft className="w-4 h-4" />
              <span>Back to sign in</span>
            </Link>
          </CardHeader>

          <CardContent>
            {isSuccess ? (
              <div className="flex flex-col items-center justify-center">
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h1 className="text-2xl font-bold">
                  Password reset successful
                </h1>
              </div>
            ) : (
              <Form {...form}>
                <form
                  onSubmit={form.handleSubmit(onSubmit)}
                  className="space-y-6"
                >
                  <FormField
                    name="newPassword"
                    control={form.control}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>New Password</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Enter your email" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    name="confirmPassword"
                    control={form.control}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>New Password</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Enter your email" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <Button type="submit" className="w-full" disabled={isPending}>
                    {isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      "Reset Password"
                    )}
                  </Button>
                </form>
              </Form>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ResetPassword;










// frontend/app/routs/auth/sign-in.tsx
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useLoginMutation } from "@/hooks/use-auth";
import { signInSchema } from "@/lib/schema";
import { useAuth } from "@/provider/auth-context";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { Link, useNavigate } from "react-router";
import { toast } from "sonner";
import { z } from "zod";
import type { User } from "@/types"; // Import User type directly

type SigninFormData = z.infer<typeof signInSchema>;

const SignIn = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const form = useForm<SigninFormData>({
    resolver: zodResolver(signInSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });
  const { mutate, isPending } = useLoginMutation();
  const handleOnSubmit = (values: SigninFormData) => {
    mutate(values, {
      onSuccess: (data: { token: string; user: User }) => { // Use proper type for data
        login(data);
        console.log(data);
        toast.success("Login successful");
        navigate("/dashboard");
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.message || "An error occurred";
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-muted/40 p-4">
      <Card className="max-w-md w-full shadow-xl">
        <CardHeader className="text-center mb-5">
          <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
          <CardDescription className="text-sm text-muted-foreground">
            Sign in to your account to continue
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-6"
            >
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email Address</FormLabel>
                    <FormControl>
                      <Input
                        type="email"
                        placeholder="email@example.com"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <div className="flex items-center justify-between">
                      <FormLabel>Password</FormLabel>
                      <Link
                        to="/forgot-password"
                        className="text-sm text-blue-600"
                      >
                        Forgot password?
                      </Link>
                    </div>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="********"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isPending}>
                {isPending ? <Loader2 className="w-4 h-4 mr-2" /> : "Sign in"}
              </Button>
            </form>
          </Form>
          <CardFooter className="flex items-center justify-center mt-6">
            <div className="flex items-center justify-center">
              <p className="text-sm text-muted-foreground">
                Don&apos;t have an account? <Link to="/sign-up">Sign up</Link>
              </p>
            </div>
          </CardFooter>
        </CardContent>
      </Card>
    </div>
  );
};

export default SignIn;











\\frontend/app/routes/auth/sign-up.tsx

import { signInSchema, signUpSchema } from "@/lib/schema";
import React, { useEffect, useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Link, useNavigate, useSearchParams } from "react-router";
import { useSignUpMutation } from "@/hooks/use-auth";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Info, UserPlus } from "lucide-react";

export type SignupFormData = z.infer<typeof signUpSchema>;

const SignUp = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const ref = searchParams.get("ref");
  const [isReferral, setIsReferral] = useState(false);
  const [referralInfo, setReferralInfo] = useState<{ name: string; email: string } | null>(null);
  
  const form = useForm<SignupFormData>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      email: "",
      password: "",
      name: "",
      confirmPassword: "",
    },
  });
  
  const { mutate, isPending } = useSignUpMutation();
  
  // Check if this is a referral signup and fetch manager info
  useEffect(() => {
    if (ref) {
      setIsReferral(true);
      // In a real app, you would fetch the manager info here
      // For now, we'll just show a generic message
      setReferralInfo({
        name: "Manager",
        email: "manager@example.com"
      });
    }
  }, [ref]);
  
  const handleOnSubmit = (values: SignupFormData) => {
    // Add referral ID to the form data if present
    const signupData = ref ? { ...values, ref } : values;
    
    mutate(signupData, {
      onSuccess: () => {
        toast.success("Email Verification Required", {
          description:
            "Please check your email for a verification link. If you don't see it, please check your spam folder.",
        });
        form.reset();
        navigate("/sign-in");
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.message || "An error occurred";
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-muted/40 p-4">
      <div className="w-full max-w-md space-y-6">
        <div className="flex flex-col items-center justify-center space-y-2">
          <h1 className="text-2xl font-bold">
            {isReferral ? "Join Your Team" : "Create an account"}
          </h1>
          <CardDescription className="text-sm text-muted-foreground">
            {isReferral 
              ? "You've been invited to join a team. Create your account to get started."
              : "Create an account to continue"
            }
          </CardDescription>
        </div>
        
        {isReferral && (
          <Alert className="bg-blue-50 border-blue-200">
            <Info className="h-4 w-4 text-blue-600" />
            <AlertDescription className="text-blue-800">
              You're signing up as a team member. You'll be able to view projects but not modify them.
            </AlertDescription>
          </Alert>
        )}
        
        <Card className="max-w-md w-full shadow-xl">
          <CardHeader className="text-center mb-5">
            <CardTitle className="text-2xl font-bold flex items-center justify-center gap-2">
              <UserPlus className="h-6 w-6" />
              {isReferral ? "Join Team" : "Sign Up"}
            </CardTitle>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form
                onSubmit={form.handleSubmit(handleOnSubmit)}
                className="space-y-6"
              >
                <FormField
                  control={form.control}
                  name="name"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Full Name</FormLabel>
                      <FormControl>
                        <Input type="text" placeholder="Minhajul Islam" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="email"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Email Address</FormLabel>
                      <FormControl>
                        <Input
                          type="email"
                          placeholder="email@example.com"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="password"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Password</FormLabel>
                      <FormControl>
                        <Input
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="confirmPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Confirm Password</FormLabel>
                      <FormControl>
                        <Input
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <Button type="submit" className="w-full" disabled={isPending}>
                  {isPending ? "Signing up..." : (isReferral ? "Join Team" : "Sign up")}
                </Button>
              </form>
            </Form>
            <CardFooter className="flex items-center justify-center mt-6">
              <div className="flex items-center justify-center">
                <p className="text-sm text-muted-foreground">
                  Already have an account? <Link to="/sign-in">Sign in</Link>
                </p>
              </div>
            </CardFooter>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default SignUp;









\\frontend/app/routes/auth/verify-email.tsx

import { Card, CardContent, CardHeader } from "@/components/ui/card";
import React, { useEffect, useState } from "react";
import { Link, useSearchParams } from "react-router";
import { ArrowLeft, CheckCircle, Loader, XCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useVerifyEmailMutation } from "@/hooks/use-auth";
import { toast } from "sonner";

const VerifyEmail = () => {
  const [searchParams] = useSearchParams();

  const token = searchParams.get("token");
  const [isSuccess, setIsSuccess] = useState(false);
  const { mutate, isPending: isVerifying } = useVerifyEmailMutation();

  useEffect(() => {
    if (token) {
      mutate(
        { token },
        {
          onSuccess: () => {
            setIsSuccess(true);
          },
          onError: (error: any) => {
            const errorMessage =
              error.response?.data?.message || "An error occurred";
            setIsSuccess(false);
            console.log(error);

            toast.error(errorMessage);
          },
        }
      );
    }
  }, [searchParams]);

  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <h1 className="text-2xl font-bold">Verify Email</h1>
      <p className="text-sm text-gray-500">Verifying your email...</p>

      <Card className="w-full max-w-md">
        {/* <CardHeader>
          <Link to="/sign-in" className="flex items-center gap-2 text-sm">
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Sign in
          </Link>
        </CardHeader> */}

        <CardContent>
          <div className="flex flex-col items-center justify-center py-6 ">
            {isVerifying ? (
              <>
                <Loader className="w-10 h-10 text-gray-500 animate-spin" />
                <h3 className="text-lg font-semibold">Verifying email...</h3>
                <p className="text-sm text-gray-500">
                  Please wait while we verify your email.
                </p>
              </>
            ) : isSuccess ? (
              <>
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h3 className="text-lg font-semibold">Email Verified</h3>
                <p className="text-sm text-gray-500">
                  Your email has been verified successfully.
                </p>
                <Link to="/sign-in" className="text-sm text-blue-500 mt-6">
                  <Button variant="outline">Back to Sign in</Button>
                </Link>
              </>
            ) : (
              <>
                <XCircle className="w-10 h-10 text-red-500" />
                <h3 className="text-lg font-semibold">
                  Email Verification Failed
                </h3>
                <p className="text-sm text-gray-500">
                  Your email verification failed. Please try again.
                </p>

                <Link to="/sign-in" className="text-sm text-blue-500 mt-6">
                  <Button variant="outline">Back to Sign in</Button>
                </Link>
              </>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default VerifyEmail;










// frontend/app/component/routs/dashboard-layout.tsx
import { Header } from "@/components/layout/header";
import { SidebarComponent } from "@/components/layout/sidebar-component";
import { Loader } from "@/components/loader";
import { useAuth } from "@/provider/auth-context";
import { Navigate, Outlet, useLocation } from "react-router";
import { useState, useEffect } from "react";

const DashboardLayout = () => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();
  const [selectedProject, setSelectedProject] = useState<any>(null);
  
  if (isLoading) {
    return <Loader />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />;
  }
  
  const handleProjectSelect = (project: any) => {
    console.log("DashboardLayout handleProjectSelect:", project); // Debug log
    setSelectedProject(project);
  };
  
  // Only pass the project selection context on the dashboard page
  const isDashboard = location.pathname === '/dashboard';
  
  return (
    <div className="flex h-screen w-full">
      <SidebarComponent />
      <div className="flex flex-1 flex-col h-full">
        <Header 
          onProjectSelect={isDashboard ? handleProjectSelect : undefined} 
          selectedProject={isDashboard ? selectedProject : undefined} 
        />
        <main className="flex-1 overflow-y-auto h-full w-full">
          <div className="mx-auto container px-2 sm:px-6 lg:px-8 py-0 md:py-8 w-full h-full">
            <Outlet context={{ selectedProject: isDashboard ? selectedProject : null }} />
          </div>
        </main>
      </div>
    </div>
  );
};

export default DashboardLayout;



\\frontend/app/routes/dashboard/index.tsx

import Dashboard from "../../components/dashboard/Dashboard";

// The DashboardLayout will already be rendered by the router.
// This component only needs to render its specific content.
export default function DashboardPage() {
  return <Dashboard />;
}











\\frontend/app/routes/emails/index.tsx

import EmailManagement from "../../components/emails/email-management";


// The DashboardLayout will already be rendered by the router.
// This component only needs to render its specific content.
export default function EmailsPage() {
  return <EmailManagement />;
}












// frontend/routes/projects/$projectId.tsx
import { useParams } from "react-router-dom";
import { ProjectDetail } from "../../components/projects/ProjectDetail";

export default function ProjectDetailRoute() {
  const { projectId } = useParams<{ projectId: string }>();
  
  if (!projectId) {
    return <div>Project ID is required</div>;
  }
  
  return <ProjectDetail />;
}











// frontend/routes/projects/index.tsx
import ProjectManagement from "../../components/projects/project-management";

export default function ProjectsPage() {
  return <ProjectManagement />;
}









\\frontend/app/routes/home.tsx
import React from "react";
import type { Route } from "../../+types/root";
import { Button } from "@/components/ui/button";
import { Link } from "react-router";
import { Wrench, BarChart3, Users, CheckCircle, ArrowRight, Star, Shield, Zap } from "lucide-react";
import { useNavigate } from "react-router";

export function meta({}: Route.MetaArgs) {
  return [
    { title: "TaskHub - Project Management Made Simple" },
    { name: "description", content: "Streamline your project management with TaskHub. Create, manage, and track projects with ease. Invite team members and collaborate effectively." },
  ];
}

const Homepage = () => {
  const navigate = useNavigate();

  const features = [
    {
      icon: <BarChart3 className="h-8 w-8 text-blue-600" />,
      title: "Project Dashboard",
      description: "Get a comprehensive overview of all your projects with intuitive dashboards and real-time analytics.",
    },
    {
      icon: <Users className="h-8 w-8 text-green-600" />,
      title: "Team Collaboration",
      description: "Invite team members and collaborate effectively with role-based access control and permissions.",
    },
    {
      icon: <CheckCircle className="h-8 w-8 text-purple-600" />,
      title: "Progress Tracking",
      description: "Track project stages and milestones with visual progress indicators and completion tracking.",
    },
    {
      icon: <Shield className="h-8 w-8 text-red-600" />,
      title: "Secure & Reliable",
      description: "Enterprise-grade security with user authentication and data protection for your projects.",
    },
    {
      icon: <Zap className="h-8 w-8 text-yellow-600" />,
      title: "Fast & Efficient",
      description: "Lightning-fast performance with a responsive interface that works seamlessly across devices.",
    },
    {
      icon: <Star className="h-8 w-8 text-indigo-600" />,
      title: "Export & Share",
      description: "Export project details as PDF and share with stakeholders for better communication.",
    },
  ];

  const howItWorks = [
    {
      step: "1",
      title: "Sign Up as Manager",
      description: "Create your manager account and set up your project workspace.",
    },
    {
      step: "2",
      title: "Create Projects",
      description: "Create unlimited projects with custom stages and track their progress.",
    },
    {
      step: "3",
      title: "Invite Team Members",
      description: "Generate invite links for team members to join your projects with limited access.",
    },
    {
      step: "4",
      title: "Track & Manage",
      description: "Monitor progress and export reports to keep everyone aligned.",
    },
  ];

  return (
    <div className="min-h-screen">
      {/* Navigation */}
      <nav className="flex items-center justify-between p-6 bg-white shadow-sm">
        <div className="flex items-center space-x-2">
          <Wrench className="h-8 w-8 text-blue-600" />
          <span className="text-2xl font-bold text-gray-900">TaskHub</span>
        </div>
        <div className="flex items-center space-x-4">
          <Link to="/sign-in">
            <Button variant="ghost" className="text-gray-600 hover:text-gray-900">
              Sign In
            </Button>
          </Link>
          <Link to="/sign-up">
            <Button className="bg-blue-600 hover:bg-blue-700 text-white">
              Get Started
            </Button>
          </Link>
        </div>
      </nav>

      {/* Hero Section */}
      <section className="py-20 px-6 bg-gradient-to-br from-blue-50 to-indigo-100">
        <div className="max-w-7xl mx-auto grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
          <div>
            <h1 className="text-5xl font-bold text-gray-900 leading-tight mb-6">
              Project Management <span className="text-blue-600">Simplified</span>
            </h1>
            <p className="text-xl text-gray-600 mb-8 leading-relaxed">
              Streamline your projects with TaskHub - the intuitive platform that helps managers create, 
              track, and collaborate on projects while providing team members with the perfect view of progress.
            </p>
            <div className="flex flex-col sm:flex-row gap-4">
              <Link to="/sign-up">
                <Button size="lg" className="bg-blue-600 hover:bg-blue-700 text-white px-8 py-3 text-lg">
                  Get Started Free
                  <ArrowRight className="ml-2 h-5 w-5" />
                </Button>
              </Link>
              <Link to="/sign-in">
                <Button size="lg" variant="outline" className="px-8 py-3 text-lg">
                  Sign In
                </Button>
              </Link>
            </div>
          </div>
          <div className="relative">
            <div className="bg-white rounded-2xl shadow-xl p-8 border border-gray-200">
              <div className="space-y-6">
                {/* Dashboard Preview */}
                <div className="bg-gray-50 rounded-lg p-4">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="font-semibold text-gray-800">Project Overview</h3>
                    <div className="flex space-x-2">
                      <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
                      <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                      <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    <div className="bg-blue-100 rounded p-3 text-center">
                      <div className="text-2xl font-bold text-blue-700">12</div>
                      <div className="text-xs text-blue-600">Total Projects</div>
                    </div>
                    <div className="bg-green-100 rounded p-3 text-center">
                      <div className="text-2xl font-bold text-green-700">8</div>
                      <div className="text-xs text-green-600">Completed</div>
                    </div>
                    <div className="bg-yellow-100 rounded p-3 text-center">
                      <div className="text-2xl font-bold text-yellow-700">4</div>
                      <div className="text-xs text-yellow-600">In Progress</div>
                    </div>
                  </div>
                </div>
                
                {/* Project List Preview */}
                <div className="space-y-3">
                  <div className="flex items-center justify-between p-3 bg-white border border-gray-200 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-blue-500 rounded-full"></div>
                      <div>
                        <div className="font-medium text-gray-800">Website Redesign</div>
                        <div className="text-xs text-gray-500">Due: Dec 15, 2023</div>
                      </div>
                    </div>
                    <div className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Ongoing</div>
                  </div>
                  
                  <div className="flex items-center justify-between p-3 bg-white border border-gray-200 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                      <div>
                        <div className="font-medium text-gray-800">Mobile App Launch</div>
                        <div className="text-xs text-gray-500">Due: Nov 30, 2023</div>
                      </div>
                    </div>
                    <div className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Completed</div>
                  </div>
                  
                  <div className="flex items-center justify-between p-3 bg-white border border-gray-200 rounded-lg">
                    <div className="flex items-center space-x-3">
                      <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>
                      <div>
                        <div className="font-medium text-gray-800">Marketing Campaign</div>
                        <div className="text-xs text-gray-500">Due: Jan 10, 2024</div>
                      </div>
                    </div>
                    <div className="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">Planning</div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Decorative elements */}
            <div className="absolute -top-4 -right-4 w-24 h-24 bg-blue-200 rounded-full opacity-50"></div>
            <div className="absolute -bottom-4 -left-4 w-16 h-16 bg-indigo-200 rounded-full opacity-50"></div>
          </div>
        </div>
      </section>

      {/* How It Works Section */}
      <section className="py-20 px-6 bg-white">
        <div className="max-w-7xl mx-auto">
          <div className="text-center mb-16">
            <h2 className="text-4xl font-bold text-gray-900 mb-4">How TaskHub Works</h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Get started in minutes and transform the way your team manages projects with our simple 4-step process.
            </p>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
            {howItWorks.map((item, index) => (
              <div key={index} className="text-center">
                <div className="w-16 h-16 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-4">
                  <span className="text-2xl font-bold text-blue-600">{item.step}</span>
                </div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">{item.title}</h3>
                <p className="text-gray-600">{item.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className="py-20 px-6 bg-gray-50">
        <div className="max-w-7xl mx-auto">
          <div className="text-center mb-16">
            <h2 className="text-4xl font-bold text-gray-900 mb-4">Everything You Need to Succeed</h2>
            <p className="text-xl text-gray-600 max-w-3xl mx-auto">
              Powerful features designed to make project management simple and effective for teams of all sizes.
            </p>
          </div>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
            {features.map((feature, index) => (
              <div key={index} className="bg-white p-8 rounded-xl shadow-sm border border-gray-200 hover:shadow-md transition-shadow">
                <div className="mb-4">
                  {feature.icon}
                </div>
                <h3 className="text-xl font-semibold text-gray-900 mb-3">{feature.title}</h3>
                <p className="text-gray-600">{feature.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Role-Based Access Section */}
      <section className="py-20 px-6 bg-white">
        <div className="max-w-7xl mx-auto">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
            <div>
              <h2 className="text-4xl font-bold text-gray-900 mb-6">Perfect for Teams</h2>
              <p className="text-lg text-gray-600 mb-8">
                TaskHub is designed with role-based access control, ensuring everyone on your team has the right level of access to contribute effectively.
              </p>
              
              <div className="space-y-6">
                <div className="flex items-start space-x-4">
                  <div className="w-10 h-10 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <BarChart3 className="h-6 w-6 text-blue-600" />
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">For Managers</h3>
                    <p className="text-gray-600">Create projects, manage stages, invite team members, and export detailed reports.</p>
                  </div>
                </div>
                
                <div className="flex items-start space-x-4">
                  <div className="w-10 h-10 bg-green-100 rounded-lg flex items-center justify-center flex-shrink-0">
                    <Users className="h-6 w-6 text-green-600" />
                  </div>
                  <div>
                    <h3 className="text-lg font-semibold text-gray-900 mb-1">For Team Members</h3>
                    <p className="text-gray-600">View project progress, track milestones, and stay updated with limited access permissions.</p>
                  </div>
                </div>
              </div>
            </div>
            
            <div className="bg-gray-50 rounded-2xl p-8">
              <div className="space-y-6">
                <div className="bg-white rounded-xl p-6 shadow-sm border border-gray-200">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="font-semibold text-gray-800">Manager Dashboard</h3>
                    <div className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Full Access</div>
                  </div>
                  <div className="space-y-3">
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">Create and edit projects</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">Manage project stages</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">Invite team members</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">Export project reports</span>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white rounded-xl p-6 shadow-sm border border-gray-200">
                  <div className="flex items-center justify-between mb-4">
                    <h3 className="font-semibold text-gray-800">Team Member View</h3>
                    <div className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded">Limited Access</div>
                  </div>
                  <div className="space-y-3">
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">View assigned projects</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <CheckCircle className="h-4 w-4 text-green-500" />
                      <span className="text-sm text-gray-700">Track project progress</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <div className="h-4 w-4 rounded border border-gray-300"></div>
                      <span className="text-sm text-gray-400">Cannot modify projects</span>
                    </div>
                    <div className="flex items-center space-x-2">
                      <div className="h-4 w-4 rounded border border-gray-300"></div>
                      <span className="text-sm text-gray-400">Cannot invite users</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20 px-6 bg-gradient-to-r from-blue-600 to-indigo-700">
        <div className="max-w-4xl mx-auto text-center">
          <h2 className="text-4xl font-bold text-white mb-6">Ready to Transform Your Project Management?</h2>
          <p className="text-xl text-blue-100 mb-8">
            Join thousands of teams already using TaskHub to streamline their projects and boost productivity.
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link to="/sign-up">
              <Button size="lg" className="bg-white text-blue-600 hover:bg-gray-100 px-8 py-3 text-lg">
                Get Started Free
                <ArrowRight className="ml-2 h-5 w-5" />
              </Button>
            </Link>
            <Link to="/sign-in">
              <Button size="lg" variant="outline" className="border-white text-white hover:bg-white hover:text-blue-600 px-8 py-3 text-lg">
                Sign In to Your Account
              </Button>
            </Link>
          </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="bg-gray-900 text-white py-12 px-6">
        <div className="max-w-7xl mx-auto">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
            <div>
              <div className="flex items-center space-x-2 mb-4">
                <Wrench className="h-8 w-8 text-blue-400" />
                <span className="text-2xl font-bold">TaskHub</span>
              </div>
              <p className="text-gray-400">
                Project management simplified for teams of all sizes.
              </p>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold mb-4">Product</h3>
              <ul className="space-y-2 text-gray-400">
                <li><Link to="#" className="hover:text-white">Features</Link></li>
                <li><Link to="#" className="hover:text-white">Pricing</Link></li>
                <li><Link to="#" className="hover:text-white">Integrations</Link></li>
                <li><Link to="#" className="hover:text-white">Updates</Link></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold mb-4">Company</h3>
              <ul className="space-y-2 text-gray-400">
                <li><Link to="#" className="hover:text-white">About</Link></li>
                <li><Link to="#" className="hover:text-white">Blog</Link></li>
                <li><Link to="#" className="hover:text-white">Careers</Link></li>
                <li><Link to="#" className="hover:text-white">Contact</Link></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold mb-4">Support</h3>
              <ul className="space-y-2 text-gray-400">
                <li><Link to="#" className="hover:text-white">Help Center</Link></li>
                <li><Link to="#" className="hover:text-white">Documentation</Link></li>
                <li><Link to="#" className="hover:text-white">Community</Link></li>
                <li><Link to="#" className="hover:text-white">Status</Link></li>
              </ul>
            </div>
          </div>
          
          <div className="border-t border-gray-800 mt-8 pt-8 text-center text-gray-400">
            <p>&copy; 2025 TaskHub. All rights reserved.</p>
          </div>
        </div>
      </footer>
    </div>
  );
};

export default Homepage;







\\frontend/app/routes/stages/index.tsx

import StageManagement from "../../components/stages/stage-management";

export default function StagesPage() {
  return <StageManagement />;
}










\\frontend/app/routes/user/profile.tsx
import { BackButton } from "@/components/back-button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import {
  useChangePassword,
  useUpdateUserProfile,
  useUserProfileQuery,
} from "@/hooks/use-user";
import { useAuth } from "@/provider/auth-context";
import { useGetReferralLink, useReferredUsers, useToggleUserStatus } from "@/hooks/useUserManagement";
import type { User } from "@/types";
import { zodResolver } from "@hookform/resolvers/zod";
import { AlertCircle, Copy, Loader, Loader2, Users, Link as LinkIcon, CheckCircle, XCircle } from "lucide-react";
import { useForm } from "react-hook-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import { useState } from "react";
import { z } from "zod";

const changePasswordSchema = z
  .object({
    currentPassword: z
      .string()
      .min(1, { message: "Current password is required" }),
    newPassword: z.string().min(8, { message: "New password is required" }),
    confirmPassword: z
      .string()
      .min(8, { message: "Confirm password is required" }),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

const profileSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  profilePicture: z.string().optional(),
});

export type ChangePasswordFormData = z.infer<typeof changePasswordSchema>;
export type ProfileFormData = z.infer<typeof profileSchema>;

const Profile = () => {
  const { data: user, isPending } = useUserProfileQuery() as {
    data: User;
    isPending: boolean;
  };
  const { logout } = useAuth();
  const navigate = useNavigate();
  
  // User management hooks for managers
  const { data: referredUsers, isLoading: isLoadingReferredUsers } = useReferredUsers();
  const { data: referralLinkData } = useGetReferralLink();
  const { mutate: toggleUserStatus, isPending: isTogglingStatus } = useToggleUserStatus();
  
  const [copied, setCopied] = useState(false);
  
  const form = useForm<ChangePasswordFormData>({
    resolver: zodResolver(changePasswordSchema),
    defaultValues: {
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
  });
  
  const profileForm = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: user?.name || "",
      profilePicture: user?.profilePicture || "",
    },
    values: {
      name: user?.name || "",
      profilePicture: user?.profilePicture || "",
    },
  });
  
  const { mutate: updateUserProfile, isPending: isUpdatingProfile } =
    useUpdateUserProfile();
  const {
    mutate: changePassword,
    isPending: isChangingPassword,
    error,
  } = useChangePassword();
  
  const handlePasswordChange = (values: ChangePasswordFormData) => {
    changePassword(values, {
      onSuccess: () => {
        toast.success(
          "Password updated successfully. You will be logged out. Please login again."
        );
        form.reset();
        setTimeout(() => {
          logout();
          navigate("/sign-in");
        }, 3000);
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.error || "Failed to update password";
        toast.error(errorMessage);
        console.log(error);
      },
    });
  };
  
  const handleProfileFormSubmit = (values: ProfileFormData) => {
    updateUserProfile(
      { name: values.name, profilePicture: values.profilePicture || "" },
      {
        onSuccess: () => {
          toast.success("Profile updated successfully");
        },
        onError: (error: any) => {
          const errorMessage =
            error.response?.data?.error || "Failed to update profile";
          toast.error(errorMessage);
          console.log(error);
        },
      }
    );
  };
  
  const handleToggleUserStatus = (userId: string, isActive: boolean) => {
    toggleUserStatus({ userId }, {
      onSuccess: () => {
        toast.success(`User ${isActive ? 'deactivated' : 'activated'} successfully`);
      },
      onError: (error: any) => {
        const errorMessage = error.response?.data?.error || "Failed to update user status";
        toast.error(errorMessage);
      }
    });
  };
  
  const copyReferralLink = () => {
    if (referralLinkData?.referralLink) {
      navigator.clipboard.writeText(referralLinkData.referralLink);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  if (isPending)
    return (
      <div className="flex justify-center items-center h-screen">
        <Loader className="animate-spin" />
      </div>
    );

  return (
    <div className="space-y-8">
      <div className="px-4 md:px-0">
        <BackButton />
        <h3 className="text-lg font-medium">Profile Information</h3>
        <p className="text-sm text-muted-foreground">
          Manage your account settings and preferences.
        </p>
      </div>
      
      <Separator />
      
      {/* User Role Badge */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium">Role:</span>
        <span className={`px-2 py-1 rounded-full text-xs font-medium ${
          user?.role === "manager" 
            ? "bg-blue-100 text-blue-800" 
            : "bg-green-100 text-green-800"
        }`}>
          {user?.role === "manager" ? "Manager" : "User"}
        </span>
      </div>
      
      {/* Referral Link Section - Only for Managers */}
      {user?.role === "manager" && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <LinkIcon className="h-5 w-5 text-blue-600" />
              Referral Link
            </CardTitle>
            <CardDescription>
              Share this link with others to invite them to your team as users
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="flex items-center gap-2">
              <Input 
                value={referralLinkData?.referralLink || ""} 
                readOnly 
                className="flex-1"
              />
              <Button 
                onClick={copyReferralLink}
                variant="outline"
                size="sm"
                className="flex items-center gap-1"
              >
                {copied ? <CheckCircle className="h-4 w-4" /> : <Copy className="h-4 w-4" />}
                {copied ? "Copied!" : "Copy"}
              </Button>
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Referred Users Section - Only for Managers */}
      {user?.role === "manager" && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5 text-blue-600" />
              Team Members
            </CardTitle>
            <CardDescription>
              Manage users who signed up with your referral link
            </CardDescription>
          </CardHeader>
          <CardContent>
            {isLoadingReferredUsers ? (
              <div className="flex justify-center py-4">
                <Loader2 className="h-6 w-6 animate-spin" />
              </div>
            ) : referredUsers && referredUsers.length > 0 ? (
              <div className="space-y-4">
                {referredUsers.map((referredUser: User) => (
                  <div key={referredUser._id} className="flex items-center justify-between p-3 border rounded-lg">
                    <div className="flex items-center gap-3">
                      <Avatar className="h-8 w-8">
                        <AvatarImage src={referredUser.profilePicture} alt={referredUser.name} />
                        <AvatarFallback>
                          {referredUser.name?.charAt(0).toUpperCase()}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <p className="font-medium">{referredUser.name}</p>
                        <p className="text-sm text-muted-foreground">{referredUser.email}</p>
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      <span className={`px-2 py-1 rounded-full text-xs font-medium ${
                        referredUser.isActive 
                          ? "bg-green-100 text-green-800" 
                          : "bg-red-100 text-red-800"
                      }`}>
                        {referredUser.isActive ? "Active" : "Inactive"}
                      </span>
                      <Button
                        onClick={() => handleToggleUserStatus(referredUser._id, referredUser.isActive)}
                        variant="outline"
                        size="sm"
                        disabled={isTogglingStatus}
                      >
                        {referredUser.isActive ? "Deactivate" : "Activate"}
                      </Button>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-4 text-muted-foreground">
                <p>No team members yet</p>
                <p className="text-sm">Share your referral link to invite users</p>
              </div>
            )}
          </CardContent>
        </Card>
      )}
      
      {/* Personal Information Card */}
      <Card>
        <CardHeader>
          <CardTitle>Personal Information</CardTitle>
          <CardDescription>Update your personal details.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...profileForm}>
            <form
              onSubmit={profileForm.handleSubmit(handleProfileFormSubmit)}
              className="grid gap-4"
            >
              <div className="flex items-center space-x-4 mb-6">
                <Avatar className="h-20 w-20 bg-gray-600">
                  <AvatarImage
                    src={
                      profileForm.watch("profilePicture") ||
                      user?.profilePicture
                    }
                    alt={user?.name}
                  />
                  <AvatarFallback className="text-xl">
                    {user?.name?.charAt(0) || "U"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <input
                    id="avatar-upload"
                    type="file"
                    accept="image/*"
                    style={{ display: "none" }}
                  />
                  <Button
                    type="button"
                    size="sm"
                    variant="outline"
                    onClick={() =>
                      document.getElementById("avatar-upload")?.click()
                    }
                  >
                    Change Avatar
                  </Button>
                </div>
              </div>
              
              <FormField
                control={profileForm.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Full Name</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <div className="grid gap-2">
                <Label htmlFor="email">Email Address</Label>
                <Input
                  id="email"
                  type="email"
                  defaultValue={user?.email}
                  disabled
                />
                <p className="text-xs text-muted-foreground">
                  Your email address cannot be changed.
                </p>
              </div>
              
              <Button
                type="submit"
                className="w-fit"
                disabled={isUpdatingProfile || isPending}
              >
                {isUpdatingProfile ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  "Save Changes"
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
      
      {/* Security Card */}
      <Card>
        <CardHeader>
          <CardTitle>Security</CardTitle>
          <CardDescription>Update your password.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handlePasswordChange)}
              className="grid gap-4"
            >
              {error && (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error.message}</AlertDescription>
                </Alert>
              )}
              
              <div className="grid gap-2">
                <FormField
                  control={form.control}
                  name="currentPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Current Password</FormLabel>
                      <FormControl>
                        <Input
                          id="current-password"
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="newPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>New Password</FormLabel>
                      <FormControl>
                        <Input
                          id="new-password"
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                
                <FormField
                  control={form.control}
                  name="confirmPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Confirm Password</FormLabel>
                      <FormControl>
                        <Input
                          id="confirm-password"
                          placeholder="********"
                          type="password"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
              
              <Button
                type="submit"
                className="mt-2 w-fit"
                disabled={isPending || isChangingPassword}
              >
                {isPending || isChangingPassword ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Updating...
                  </>
                ) : (
                  "Update Password"
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};

export default Profile;




\\frontend/app/routes/user/user-layout.tsx
import { Outlet } from "react-router";

const UserLayout = () => {
  return (
    <div className="container max-w-3xl mx-auto py-8 md:py-16">
      <Outlet />
    </div>
  );
};

export default UserLayout;













\\frontend/app/types/index.ts


export interface User {
  _id: string;
  email: string;
  name: string;
  createdAt: Date;
  isEmailVerified: boolean;
  updatedAt: Date;
  profilePicture?: string;
  role: "manager" | "user";
  referredBy?: string;
  referralLink?: string;
  isActive: boolean;
}

export enum ProjectStatus {
  IN_PROGRESS = "In Progress",
  COMPLETED = "Completed",
}

// Project types
export interface Project {
  _id: string;
  project_name: string;
  description: string;
  status: 'Pending' | 'Ongoing' | 'Completed' | 'Archived';
  created_at: string;
  updated_at: string | null;
  owner: {
    _id: string;
    name: string;
    email: string;
  };
}

// Form types
export interface ProjectFormData {
  project_name: string;
  description: string;
  created_at: string;
}

// API response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// Auth types
export interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
}

export interface Subtask {
  _id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
}

export interface Attachment {
  fileName: string;
  fileUrl: string;
  fileType: string;
  fileSize: number;
  uploadedBy: string;
  uploadedAt: Date;
  _id: string;
}

export type ResourceType =
  | "Project"
  | "User";

export interface StatsCardProps {
  totalProjects: number;
  totalTasks: number;
  totalProjectInProgress: number;
  totalTaskCompleted: number;
  totalTaskToDo: number;
  totalTaskInProgress: number;
}

export interface ProjectStatusData {
  name: string;
  value: number;
  color: string;
}












\\frontend/app/app.css
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme {
  --font-sans: "Inter", ui-sans-serif, system-ui, sans-serif,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}

html,
body {
  @apply bg-white dark:bg-gray-950;

  @media (prefers-color-scheme: dark) {
    color-scheme: dark;
  }
}

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.208 0.042 265.755);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.208 0.042 265.755);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.929 0.013 255.508);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.551 0.027 264.364);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.551 0.027 264.364);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}













// frontend/app/root.tsx
import {
  isRouteErrorResponse,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "react-router";

import type { Route } from "./+types/root";
import "./app.css";
import ReactQueryProvider from "./provider/react-query-provider";
import { TooltipProvider } from "./components/ui/tooltip";

export const links: Route.LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  {
    rel: "preconnect",
    href: "https://fonts.gstatic.com",
    crossOrigin: "anonymous",
  },
  {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <TooltipProvider>
      <ReactQueryProvider>
        <Outlet />
      </ReactQueryProvider>
    </TooltipProvider>
  );
}

export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack: string | undefined;

  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details =
      error.status === 404
        ? "The requested page could not be found."
        : error.statusText || details;
  } else if (import.meta.env.DEV && error && error instanceof Error) {
    details = error.message;
    stack = error.stack;
  }

  return (
    <main className="pt-16 p-4 container mx-auto">
      <h1>{message}</h1>
      <p>{details}</p>
      {stack && (
        <pre className="w-full p-4 overflow-x-auto">
          <code>{stack}</code>
        </pre>
      )}
    </main>
  );
}










//backend/app/app/routses.ts
import {
  type RouteConfig,
  index,
  layout,
  route,
} from "@react-router/dev/routes";

export default [
  layout("routes/auth/auth-layout.tsx", [
    index("routes/root/home.tsx"),
    route("sign-in", "routes/auth/sign-in.tsx"),
    route("sign-up", "routes/auth/sign-up.tsx"),
    route("forgot-password", "routes/auth/forgot-password.tsx"),
    route("reset-password", "routes/auth/reset-password.tsx"),
    route("verify-email", "routes/auth/verify-email.tsx"),
  ]),
  layout("routes/dashboard/dashboard-layout.tsx", [
    route("dashboard", "routes/dashboard/index.tsx"),
    route("emails", "routes/emails/index.tsx"),
    route("projects", "routes/projects/index.tsx"),
    route("projects/:projectId", "routes/projects/$projectId.tsx"),
    route("stages", "routes/stages/index.tsx"),
  ]),
  layout("routes/user/user-layout.tsx", [
    route("user/profile", "routes/user/profile.tsx"),
  ]),
] satisfies RouteConfig;